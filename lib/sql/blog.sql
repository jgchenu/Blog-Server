/*
Navicat MySQL Data Transfer

Source Server         : localmysql
Source Server Version : 50721
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50721
File Encoding         : 65001

Date: 2018-10-20 01:36:59
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for apply
-- ----------------------------
DROP TABLE IF EXISTS `apply`;
CREATE TABLE `apply` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text NOT NULL,
  `sayId` int(11) NOT NULL,
  `commentId` int(11) NOT NULL,
  `toId` int(11) NOT NULL,
  `createdAt` datetime DEFAULT NULL,
  `updatedAt` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of apply
-- ----------------------------
INSERT INTO `apply` VALUES ('1', '这是第1条回复', '2', '1', '1', '2018-10-06 14:23:30', '2018-10-06 14:23:33');
INSERT INTO `apply` VALUES ('2', '这是第2条回复', '3', '1', '1', '2018-10-06 16:23:54', '2018-10-06 16:23:58');
INSERT INTO `apply` VALUES ('3', '这是第三条回复', '1', '1', '1', '2018-10-06 18:07:45', '2018-10-06 18:07:48');
INSERT INTO `apply` VALUES ('4', '<p>我还是不死心，想试下回复你的样子<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/pcmoren_wu_org.png\" alt=\"[污]\" data-w-e=\"1\"></p>', '1', '5', '1', '2018-10-10 18:47:52', '2018-10-10 18:47:52');
INSERT INTO `apply` VALUES ('5', '<p>我想回复我家小君君试一下<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/50/pcmoren_huaixiao_org.png\" alt=\"[坏笑]\" data-w-e=\"1\"></p>', '1', '1', '2', '2018-10-10 18:49:33', '2018-10-10 18:49:33');
INSERT INTO `apply` VALUES ('6', '<p>这样吧，我回复一下测试<img src=\"http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/60/horse2_thumb.gif\" alt=\"[神马]\">&nbsp;&nbsp;<br></p>', '1', '1', '3', '2018-10-10 19:06:55', '2018-10-10 19:06:55');
INSERT INTO `apply` VALUES ('7', '<p>这样吧，我回复一下测试<img src=\"http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/60/horse2_thumb.gif\" alt=\"[神马]\">&nbsp;&nbsp;<br></p>', '1', '1', '3', '2018-10-10 19:08:03', '2018-10-10 19:08:03');
INSERT INTO `apply` VALUES ('8', '<p>今天天气还可以，就是有点冷</p>', '1', '1', '2', '2018-10-11 15:36:46', '2018-10-11 15:36:46');
INSERT INTO `apply` VALUES ('9', '<p>我是第一条文章的文章的回复</p>', '2', '6', '1', '2018-10-12 11:09:55', '2018-10-12 11:10:01');
INSERT INTO `apply` VALUES ('10', '<p>我想试下第二条文章评论的回复</p>', '1', '7', '1', '2018-10-13 11:29:41', '2018-10-13 11:29:41');
INSERT INTO `apply` VALUES ('11', '<p>我想回复你一下</p>', '4', '18', '1', '2018-10-18 06:45:51', '2018-10-18 06:45:51');
INSERT INTO `apply` VALUES ('12', '<p>大大说大撒多</p>', '1', '20', '4', '2018-10-19 16:53:07', '2018-10-19 16:53:07');
INSERT INTO `apply` VALUES ('13', '<p>大大说大撒多打算打大所多</p>', '1', '5', '1', '2018-10-19 16:53:19', '2018-10-19 16:53:19');
INSERT INTO `apply` VALUES ('14', '<p>啊实打实大大所大多</p>', '1', '1', '2', '2018-10-19 16:53:37', '2018-10-19 16:53:37');

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `summary` varchar(255) DEFAULT NULL,
  `readCount` int(11) DEFAULT '0',
  `userId` int(11) NOT NULL,
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime NOT NULL,
  `deletedAt` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', '作为前端，也必须知道的hybrid知识', '1,第一，2，第二', '0', '1', '2018-09-30 01:51:35', '2018-10-10 15:18:54', null);
INSERT INTO `article` VALUES ('2', 'MVVM MVC vue 与react', '1,第一，2，第二', '0', '1', '2018-09-30 01:51:35', '2018-09-30 01:51:38', null);
INSERT INTO `article` VALUES ('3', 'pip install package 报错解决', '1,第一，2，第二', '0', '1', '2018-09-30 01:51:35', '2018-09-30 01:51:38', null);
INSERT INTO `article` VALUES ('4', '浅谈虚拟dom', '1,第一，2，第二', '0', '1', '2018-09-30 09:33:47', '2018-09-30 09:33:42', null);
INSERT INTO `article` VALUES ('5', '啊实打实大as', null, '0', '1', '2018-10-02 09:09:33', '2018-10-02 09:09:33', null);
INSERT INTO `article` VALUES ('6', '啊实打实大as', null, '0', '1', '2018-10-02 09:11:17', '2018-10-02 09:11:17', null);
INSERT INTO `article` VALUES ('7', '啊实打实大as', null, '0', '1', '2018-10-02 09:13:38', '2018-10-02 09:13:38', null);
INSERT INTO `article` VALUES ('8', '啊实打实大as', null, '0', '1', '2018-10-02 09:14:35', '2018-10-02 09:14:35', null);
INSERT INTO `article` VALUES ('9', '啊实打实大as', null, '0', '1', '2018-10-02 09:19:04', '2018-10-02 09:19:04', null);
INSERT INTO `article` VALUES ('10', '努力学习', null, '0', '1', '2018-10-02 09:27:55', '2018-10-02 09:27:55', null);
INSERT INTO `article` VALUES ('11', '啊实打实大阿萨德爱上爱上阿萨德阿萨德', null, '0', '1', '2018-10-02 09:29:55', '2018-10-02 09:29:55', null);
INSERT INTO `article` VALUES ('12', '努力学习', null, '0', '1', '2018-10-03 14:08:10', '2018-10-03 14:08:10', null);
INSERT INTO `article` VALUES ('13', '总结一些比较有趣的js代码', null, '0', '1', '2018-10-03 14:13:06', '2018-10-03 14:13:06', null);
INSERT INTO `article` VALUES ('14', '总结一些比较有趣的js代码', null, '0', '1', '2018-10-03 14:19:38', '2018-10-03 14:19:38', null);
INSERT INTO `article` VALUES ('15', '啊实打实大多', null, '0', '1', '2018-10-03 14:20:53', '2018-10-03 14:20:53', null);
INSERT INTO `article` VALUES ('16', '浅谈原型链', null, '0', '1', '2018-10-03 14:22:52', '2018-10-03 14:22:52', null);
INSERT INTO `article` VALUES ('17', '浅谈原型链', null, '0', '1', '2018-10-03 14:23:04', '2018-10-03 14:23:04', null);
INSERT INTO `article` VALUES ('18', '啊实打实大as', null, '0', '1', '2018-10-03 14:32:08', '2018-10-03 14:32:08', null);
INSERT INTO `article` VALUES ('19', '啊实打实大', null, '0', '1', '2018-10-03 14:32:34', '2018-10-05 09:00:47', '2018-10-13 16:50:44');
INSERT INTO `article` VALUES ('20', '我家傻银', null, '0', '1', '2018-10-03 14:33:03', '2018-10-07 07:50:13', null);
INSERT INTO `article` VALUES ('21', '啊实打实大', null, '0', '1', '2018-10-03 14:34:07', '2018-10-05 09:00:35', '2018-10-13 16:44:29');
INSERT INTO `article` VALUES ('22', '阿萨德a', null, '0', '1', '2018-10-03 14:35:09', '2018-10-03 14:35:09', null);
INSERT INTO `article` VALUES ('23', '萨达', null, '0', '1', '2018-10-03 14:39:33', '2018-10-03 14:39:33', '2018-10-13 16:51:11');
INSERT INTO `article` VALUES ('24', '啊实打实大撒打算', null, '0', '1', '2018-10-04 17:06:29', '2018-10-04 21:48:48', '2018-10-13 16:51:08');
INSERT INTO `article` VALUES ('25', '关于使用sequelize多表链接查询问题', null, '0', '1', '2018-10-10 15:20:58', '2018-10-10 15:20:58', null);
INSERT INTO `article` VALUES ('26', '测试一下删除', null, '0', '1', '2018-10-13 16:45:37', '2018-10-13 16:45:37', '2018-10-13 16:45:47');
INSERT INTO `article` VALUES ('27', 'jgchen', null, '0', '1', '2018-10-19 16:24:40', '2018-10-19 16:26:59', null);
INSERT INTO `article` VALUES ('28', 'jgchen', null, '0', '1', '2018-10-19 16:27:34', '2018-10-19 16:50:35', null);

-- ----------------------------
-- Table structure for board
-- ----------------------------
DROP TABLE IF EXISTS `board`;
CREATE TABLE `board` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text NOT NULL,
  `sayId` int(11) NOT NULL,
  `toId` int(11) NOT NULL,
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of board
-- ----------------------------

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text NOT NULL,
  `sayId` int(11) NOT NULL,
  `commentType` tinyint(1) NOT NULL,
  `articleId` int(11) DEFAULT NULL,
  `createdAt` datetime DEFAULT NULL,
  `updatedAt` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('1', '我爱家小君君', '2', '1', null, '2018-10-06 14:23:01', '2018-10-06 14:23:05');
INSERT INTO `comment` VALUES ('2', '我也是，我也来凑个热闹', '3', '1', null, '2018-10-06 16:56:37', '2018-10-06 16:56:39');
INSERT INTO `comment` VALUES ('3', '我是最新的一条评论', '1', '1', null, '2018-10-06 18:16:00', '2018-10-06 18:16:02');
INSERT INTO `comment` VALUES ('4', '<p>我想试下评论的感觉是怎么样的<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/40/pcmoren_tian_org.png\" alt=\"[舔屏]\" data-w-e=\"1\"></p>', '1', '2', null, '2018-10-10 18:42:16', '2018-10-10 18:42:16');
INSERT INTO `comment` VALUES ('5', '<p>我想试下回复你的样子<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/40/pcmoren_tian_org.png\" alt=\"[舔屏]\" data-w-e=\"1\"></p>', '1', '2', null, '2018-10-10 18:45:43', '2018-10-10 18:45:43');
INSERT INTO `comment` VALUES ('6', '<p>我是第一条文章的评论</p>', '2', '1', '25', '2018-10-12 11:08:26', '2018-10-12 11:08:29');
INSERT INTO `comment` VALUES ('7', '<p>我想试下第二条文章评论</p>', '1', '1', '25', '2018-10-13 11:29:25', '2018-10-13 11:29:25');
INSERT INTO `comment` VALUES ('8', '<p>我想试下第三条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '25', '2018-10-13 11:30:39', '2018-10-13 11:30:39');
INSERT INTO `comment` VALUES ('9', '<p>我想试下第4条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '25', '2018-10-13 11:31:05', '2018-10-13 11:31:05');
INSERT INTO `comment` VALUES ('10', '<p>我想试下第5条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '25', '2018-10-13 11:31:10', '2018-10-13 11:31:10');
INSERT INTO `comment` VALUES ('11', '<p>我想试下第六条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '25', '2018-10-13 11:31:20', '2018-10-13 11:31:20');
INSERT INTO `comment` VALUES ('12', '<p>我想试下第7条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '25', '2018-10-13 11:31:27', '2018-10-13 11:31:27');
INSERT INTO `comment` VALUES ('13', '<p>我想试下第8条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '1', '2018-10-13 11:31:42', '2018-10-13 11:31:42');
INSERT INTO `comment` VALUES ('14', '<p>我想试下第9条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '1', '2018-10-13 11:31:50', '2018-10-13 11:31:50');
INSERT INTO `comment` VALUES ('15', '<p>我想试下第10条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '20', '2018-10-13 11:32:06', '2018-10-13 11:32:06');
INSERT INTO `comment` VALUES ('16', '<p>我想试下11条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '19', '2018-10-13 11:32:16', '2018-10-13 11:32:16');
INSERT INTO `comment` VALUES ('17', '<p>我想试下第12条文章评论&nbsp;&nbsp;<br></p>', '1', '1', '19', '2018-10-13 11:32:29', '2018-10-13 11:32:29');
INSERT INTO `comment` VALUES ('18', '<p>测试评论</p>', '1', '1', '25', '2018-10-14 15:41:19', '2018-10-14 15:41:19');
INSERT INTO `comment` VALUES ('19', '<p>dasdadasdasdasdasd</p>', '4', '1', '25', '2018-10-18 06:45:32', '2018-10-18 06:45:32');
INSERT INTO `comment` VALUES ('20', '<p>阿达大</p>', '4', '2', null, '2018-10-18 06:59:29', '2018-10-18 06:59:29');
INSERT INTO `comment` VALUES ('21', '<p>大大大撒大多撒</p>', '1', '2', null, '2018-10-19 16:54:26', '2018-10-19 16:54:26');
INSERT INTO `comment` VALUES ('22', '<p>萨达萨达所</p>', '1', '2', null, '2018-10-19 16:55:41', '2018-10-19 16:55:41');
INSERT INTO `comment` VALUES ('23', '<p>爱上打算大所多</p>', '1', '2', null, '2018-10-19 16:55:45', '2018-10-19 16:55:45');
INSERT INTO `comment` VALUES ('24', '<p>萨达萨达所多</p>', '1', '2', null, '2018-10-19 16:56:22', '2018-10-19 16:56:22');
INSERT INTO `comment` VALUES ('25', '<p>爱上打算大所多</p>', '4', '2', null, '2018-10-19 16:58:49', '2018-10-19 16:58:49');
INSERT INTO `comment` VALUES ('26', '<p>哒哒哒哒</p>', '4', '2', null, '2018-10-19 16:59:01', '2018-10-19 16:59:01');
INSERT INTO `comment` VALUES ('27', '<p>萨达萨达所多</p>', '4', '2', null, '2018-10-19 16:59:53', '2018-10-19 16:59:53');
INSERT INTO `comment` VALUES ('28', '<p>啊实打实打算</p>', '4', '2', null, '2018-10-19 17:00:14', '2018-10-19 17:00:14');

-- ----------------------------
-- Table structure for content
-- ----------------------------
DROP TABLE IF EXISTS `content`;
CREATE TABLE `content` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `value` text,
  `articleid` int(11) NOT NULL,
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of content
-- ----------------------------
INSERT INTO `content` VALUES ('1', '<h3>hybrid 是什么？</h3>\nhybrid是客户端和前端的混合开发。\n\n<hr>\n\n<h3>hybrid 有什么用？</h3>\nhybrid存在的核心意义在于快速迭代，无需审核。\n\n<hr>\n\n<h3>hybrid 实现流程</h3>\n流程图：<div><br></div><div>&nbsp;&nbsp;<img class=\"alignnone wp-image-819\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信截图_20180816102857-300x154.png\" alt=\"\" width=\"547\" height=\"281\">&nbsp;<br></div><div><div>1.前端做好静态页面（html,js,css），将文件交给客户端。\n2.客户端拿到前端静态页面，以文件的形式存储在app中。\n3.客户端在一个webview中使用file协议加载静态页面\n\n<hr>\n\n<h3>客户端如何更新服务端的资源</h3>\n1.分版本，有版本号，如201803020201\n2.将静态文件压缩成zip包，上传到服务端\n3.客户端每次启动，都去服务端检查版本号，\n4.如果服务端的版本号大于客户端的版本号，就去下载最新的zip包，\n5.下载完之后解压包，然后将现有的文件覆盖\n\n<hr>\n\n<h3>JS和客户端通讯的基本形式</h3><div><br></div>\n<img class=\"alignnone  wp-image-823\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信截图_20180816110402-300x198.png\" alt=\"\" width=\"470\" height=\"310\">&nbsp;</div><div><br></div><div><pre><pre><code>1.js访问客户端能力，传递参数和回调函数 2.客户端通过回调函数返回内容 3.前端和客户端通讯的约定--schema协议 4.schema是内置上线的 schema模拟<br>(function (window, undefined) {<br><br>    // 调用 schema 的封装<br>    function _invoke(action, data, callback) {<br>        // 拼装 schema 协议<br>        var schema = \'myapp://utils/\' + action<br><br>        // 拼接参数<br>        schema += \'?a=a\'<br>        var key<br>        for (key in data) {<br>            if (data.hasOwnProperty(key)) {<br>                schema += \'&amp;\' + key + data[key]<br>            }<br>        }<br><br>        // 处理 callback<br>        var callbackName = \'\'<br>        if (typeof callback === \'string\') {<br>            callbackName = callback<br>        } else {<br>            callbackName = action + Date.now()<br>            window[callbackName] = callback<br>        }<br>        schema += \'callback=callbackName\'<br><br>        // 触发<br>        var iframe = document.createElement(\'iframe\')<br>        iframe.style.display = \'none\'<br>        iframe.src = schema  // 重要！<br>        var body = document.body<br>        body.appendChild(iframe)<br>        setTimeout(function () {<br>            body.removeChild(iframe)<br>            iframe = null<br>        })<br>    }<br><br>    // 暴露到全局变量<br>    window.invoke = {<br>        share: function (data, callback) {<br>            _invoke(\'share\', data, callback)<br>        },<br>        scan: function (data, callback) {<br>            _invoke(\'scan\', data, callback)<br>        },<br>        login: function (data, callback) {<br>            _invoke(\'login\', data, callback)<br>        }<br>    }<br><br>})(window)<br><br><br>        document.getElementById(\'btn1\').addEventListener(\'click\', function () {<br>            // invokeScan()<br>            window.invoke.scan({}, function () {})<br>        })<br>        document.getElementById(\'btn2\').addEventListener(\'click\', function () {<br>            window.invoke.share({<br>                title: \'xxx\',<br>                content: \'yyy\'<br>            }, function (result) {<br>                if (result.errno === 0) {<br>                    alert(\'分享成功\')<br>                } else {<br>                    alert(result.message)<br>                }<br>            })<br>        })</code></pre><p><br></p>\n</pre>\n</div></div>', '1', '2018-09-30 03:09:48', '2018-10-10 15:18:55');
INSERT INTO `content` VALUES ('2', 'jQuery跟mvvm的区别：\r\n\r\n通过一个todolist来对比下。\r\n\r\n<img class=\"alignnone wp-image-769\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信图片_20180814101451-294x300.png\" alt=\"\" width=\"411\" height=\"419\" />\r\n\r\n<img class=\"alignnone wp-image-776\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/viewModel-221x300.png\" alt=\"\" width=\"408\" height=\"554\" />\r\n\r\n很明显，jQuery是直接操控dom的，而且视图跟model操作是没有分开的，而且操控的是实际的dom，并非是数据驱动。\r\n\r\n而Vue是数据跟视图分离开的，然后由数据驱动视图的更新。\r\n\r\n1.数据跟视图的分离，解耦\r\n2.数据驱动视图，只关心数据变化，DOM操作被封装\r\n\r\n<hr/>\r\n\r\n<strong>MVC：view model controller</strong>\r\n\r\n<img class=\"alignnone wp-image-762\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信截图_20180814095550-300x293.png\" alt=\"\" width=\"374\" height=\"366\" />\r\n\r\n<img class=\"alignnone wp-image-763\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信截图_20180814095606-260x300.png\" alt=\"\" width=\"348\" height=\"402\" />\r\n\r\n<hr/>\r\n\r\n<strong>MVVM：view model viewModel</strong>\r\n<img class=\"alignnone wp-image-766\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信图片_20180814095849-300x150.png\" alt=\"\" width=\"606\" height=\"303\" />\r\n\r\n<img class=\"alignnone wp-image-765\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信截图_20180814095525-300x186.png\" alt=\"\" width=\"623\" height=\"386\" />\r\n\r\n<hr/>\r\n\r\n<h3>那么使用mvvm框架中，vue改变model中data的值，会反映到视图的改变，那么vue的响应式是如何实现的呢?</h3>\r\n核心api：Object.defineProperty;将data的属性代理到vm上。\r\n下面是模拟实现：\r\n<pre>var vm = {}\r\n        var data = {\r\n            name: \'zhangsan\',\r\n            age: 20\r\n        }\r\n\r\n        var key, value\r\n        for (key in data) {\r\n            (function (key) {\r\n                Object.defineProperty(vm, key, {\r\n                    get: function () {\r\n                        console.log(\'get\', data[key]) // 监听\r\n                        return data[key]\r\n                    },\r\n                    set: function (newVal) {\r\n                        console.log(\'set\', newVal) // 监听\r\n                        data[key] = newVal\r\n                    }\r\n                })\r\n            })(key)\r\n        }\r\n</pre>\r\n<hr/>\r\n<h3>我们在vue中书写的vue文件模板是没法直接运行的，那么怎么解析模版到最后渲染成正常的html代码呢？</h3>\r\n首先我们应该知道模板的本质是什么，模板是一整串有逻辑的字符串。\r\n模板最后必须转换成js代码，因为里面有逻辑（v-if v-for）\r\n，必须使用js才能实现（图灵完备），需要转换成html渲染页面，必须用js才能实现。\r\n因此模板最重要的要能转换成一个js函数返回vnode（render函数）\r\n\r\n下面render函数简单模拟实现：\r\n<pre>var vm = new Vue({\r\n            el: \'#app\',\r\n            data: {\r\n                price: 100\r\n            }\r\n           })\r\n\r\n      // 以下是模拟的 render 函数\r\n        function render() {\r\n            with(this) {  // this 就是 vm\r\n                return _c(\r\n                    \'div\',\r\n                    {\r\n                        attrs: {\'id\': \'app\'}\r\n                    },\r\n                    [\r\n                        _c(\'p\', [_v(_s(price))])\r\n                    ]\r\n                )\r\n            }\r\n        }\r\n\r\n        function render1() {\r\n            return vm._c(\r\n                \'div\',\r\n                {\r\n                    attrs: {\'id\': \'app\'}\r\n                },\r\n                [\r\n                    vm._c(\'p\', [vm._v(vm._s(vm.price))])\r\n                ]\r\n            )\r\n        }\r\nvm._c是创建元素节点，vm._v是创建文本节点，vm._s是toString，vm.price 是把data属性代理到vm，然后返回data.price\r\n</pre>\r\n<hr/>\r\n\r\n<h3>那么在vue的生命周期里，render函数是怎么起作用的呢？</h3>\r\n<img class=\"alignnone wp-image-788\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信图片_20180814224127-300x184.png\" alt=\"\" width=\"478\" height=\"293\" />\r\n<img class=\"alignnone wp-image-789\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信图片_20180814224523-300x85.png\" alt=\"\" width=\"476\" height=\"135\" />\r\n\r\n<hr/>\r\n<h2>下面总结一下vue的整个实现流程</h2>\r\n\r\n<h3>第一步：解析模板成render函数</h3>\r\n1.with的用法\r\n2.模板中的信息都被render函数包含\r\n3.模板中用到的data中的属性，都变成了js变量\r\n4.模板中的v-model v-for v-on都变成了js逻辑\r\n5.render函数返回vnode\r\n\r\n<img class=\"alignnone wp-image-796\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信截图_20180814230851-300x129.png\" alt=\"\" width=\"447\" height=\"192\" />\r\n\r\n<img class=\"alignnone wp-image-795\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信截图_20180814230830-193x300.png\" alt=\"\" width=\"453\" height=\"704\" />\r\n<hr/>\r\n<h3>第二步：响应式开始监听</h3>\r\n1.Object.defineProperty\r\n2.将data的属性代理到vm上\r\n<pre>var vm = {}\r\n        var data = {\r\n            name: \'zhangsan\',\r\n            age: 20\r\n        }\r\n\r\n        var key, value\r\n        for (key in data) {\r\n            (function (key) {\r\n                Object.defineProperty(vm, key, {\r\n                    get: function () {\r\n                        console.log(\'get\', data[key]) // 监听\r\n                        return data[key]\r\n                    },\r\n                    set: function (newVal) {\r\n                        console.log(\'set\', newVal) // 监听\r\n                        data[key] = newVal\r\n                    }\r\n                })\r\n            })(key)\r\n        }\r\n</pre>\r\n\r\n<hr/>\r\n\r\n<h3>第三部：首次渲染，显示页面，且绑定依赖</h3>\r\n1.初次渲染，执行updateComponent，执行vm._render()，也就是第一步返回的render函数\r\n2.执行render函数，会访问到vm.list 和vm.title\r\n3.会被响应式的get方法监听到\r\n4.执行updateComponent，会走到vdom的patch方法，\r\n5.patch将vnode渲染成dom，初次渲染完成\r\n<img class=\"alignnone wp-image-788\" src=\"http://jgchen.xin/wp-content/uploads/2018/08/微信图片_20180814224127-300x184.png\" alt=\"\" width=\"462\" height=\"283\" />\r\n\r\n<hr/>\r\n\r\n<h3>第四部：data属性变化，触发rerender</h3>\r\n有了之前第二步的监听属性的set跟get之后\r\n<pre>\r\n Object.defineProperty(vm, key, {\r\n                    get: function () {\r\n                        console.log(\'get\', data[key]) // 监听\r\n                        return data[key]\r\n                    },\r\n                    set: function (newVal) {\r\n                        console.log(\'set\', newVal) // 监听\r\n                        data[key] = newVal\r\n                }\r\n          })\r\n</pre>\r\n接下来就是第四步的内容了。\r\n1.修改属性被响应式的set监听到\r\n2.set中执行updateComponent，这一步是异步的，所以vue的属性的修改也是异步的\r\n3.updateComponent重新执行vm._render()\r\n4.生成的vnode跟prevVnode，通过patch进行对比\r\n\r\n\r\n<hr/>\r\n\r\n<h2> React </h2>\r\n\r\n<h3>组件化的理解：</h3>\r\n<h4>1.组件的封装：封装组件的视图，数据，变化逻辑</h4>\r\n<h4>2.组件的复用：props传递，复用</h4>\r\n\r\n<hr/>\r\n\r\n<h3>JSX是什么?</h3>\r\n<h4>JSX其实是语法糖</h4>\r\n<h4>开发环境将JSX编译成JS代码</h4>\r\n<h4>JSX的写法大大降低了学习成本跟编码的工作量</h4>\r\n<hr/>\r\n\r\n<h3>JSX和vdom的关系：</h3>\r\n<h4>1.jsx为什么需要vdom：jsx需要渲染成html，数据驱动视图</h4>\r\n<h4>React.createElement和h，都生成vnode，createElement需要考虑自定义组件的名称，然后将其解析为自定义组件的render函数。</h4>\r\n<h4>何时patch:ReactDom.render() 这个方法是在初次渲染的时候,执行了patch($el,Vnode) \r\nsetState在数据更新rerender的时候，执行了patch(preVnode,newVnode)</h4>\r\n<h4>自定义组件的解析：初始化实例，然后执行render</h4>\r\n<pre>\r\n例如List组件，\r\n会经过类似这样的过程：\r\nvar list =new List({data:this.state.listData})\r\nvar vnode=list.render()\r\n</pre>\r\n\r\n<hr/>\r\n\r\n<h3>React setState的过程</h3>\r\n<h4>setState是异步的，vue修改属性也是异步的</h4>\r\nsetState的过程步骤:\r\n1.每个组件的示例，都有renderComponent方法，\r\n2.执行renderComponent会重新执行实例的render\r\n3.render函数返回newVnode，然后拿到preVnode，\r\n4.执行patch(preVnode,newVnode)\r\n<pre>\r\n模拟代码\r\nrenderComponent(){\r\nconst prevVnode=this._vnode;\r\nconst newVnode=this.render();\r\npatch(prevVnode,newVnode);\r\nthis._vnode=newVnode;\r\n}\r\n</pre>\r\n<h3>为什么要异步，提高效率，如果用户多次setState，只要最终效果，渲染一遍。</h3>\r\n\r\n<hr/>\r\n\r\n<h2>React 与 Vue 的本质区别</h2>\r\n\r\n<h3>1.vue 本质是MVVM框架，由MVC发展而来。React 本质是前端组件化框架，由后端组件化发展而来</h3>\r\n<h3>2.vue使用模板，React使用JSX</h3>\r\n<h3>3.React本身就是组件化，没有组件化就不是React。vue也支持组件化，不过是在MVVM上的扩展</h3>\r\n\r\n<hr/>\r\n\r\n<h2>React 与 Vue 共同点</h2>\r\n<h3>支持组件化，数据驱动视图</h3>', '2', '2018-09-30 09:31:55', '2018-09-30 09:31:58');
INSERT INTO `content` VALUES ('3', '<pre>\r\nCould not find a version that satisfies the requirement Jinja2==2.6 (from versions: )\r\nNo matching distribution found for Jinja2==2.6\r\n\r\n总是出现类似于这种的报错，是因为网络的问题，要使用国内的镜像源来加速：pip install pymongo -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com\r\n就可以了，如果还是出错，多试几次，已经解决.\r\n</pre>\r\n', '3', '2018-09-30 09:33:01', '2018-09-30 09:33:04');
INSERT INTO `content` VALUES ('4', '我自己的理解\r\n\r\n虚拟dom：就是 通过js对象表示的DOM结构。\r\n\r\n尝试虚拟dom的原因：操作一次的dom的渲染成本远远超过与操作虚拟dom的成本，操作dom是最耗费性能的，所以通过将dom对比操作放在js层,提高效率，也就是虚拟dom。\r\n\r\n下面我们通过控制台打印来看一下，一个dom元素的复杂程度。\r\n<pre>\r\nvar div=document.createElement(\'div\')\r\nvar result=\'\'\r\n\r\nfor(let item in div){\r\nresult+=\'|\'+item;\r\n}\r\nconsole.log(result)\r\n\r\n//|align|title|lang|translate|dir|dataset|hidden|tabIndex|accessKey|draggable\r\n|spellcheck|autocapitalize|contentEditable|isContentEditable|offsetParent\r\n|offsetTop|offsetLeft|offsetWidth|offsetHeight|style|innerText|outerText\r\n|onabort|onblur|oncancel|oncanplay|oncanplaythrough|onchange|onclick|onclose\r\n|oncontextmenu|oncuechange|ondblclick|ondrag|ondragend|ondragenter|ondragleave\r\n|ondragover|ondragstart|ondrop|ondurationchange|onemptied|onended|onerror|onfocus\r\n|oninput|oninvalid|onkeydown|onkeypress|onkeyup|onload|onloadeddata|onloadedmetadata\r\n|onloadstart|onmousedown|onmouseenter|onmouseleave|onmousemove|onmouseout|onmouseover\r\n|onmouseup|onmousewheel|onpause|onplay|onplaying|onprogress|onratechange|onreset\r\n|onresize|onscroll|onseeked|onseeking|onselect|onstalled|onsubmit|onsuspend\r\n|ontimeupdate|ontoggle|onvolumechange|onwaiting|onwheel|onauxclick|ongotpointercapture|\r\nonlostpointercapture|onpointerdown|onpointermove|onpointerup|onpointercancel|\r\nonpointerover|onpointerout|onpointerenter|onpointerleave|nonce|click|focus|blur|\r\ninputMode|namespaceURI|prefix|localName|tagName|id|className|classList|slot|attributes|\r\nshadowRoot|assignedSlot|innerHTML|outerHTML|scrollTop|scrollLeft|scrollWidth|\r\nscrollHeight|clientTop|clientLeft|clientWidth|clientHeight|onbeforecopy|onbeforecut|\r\nonbeforepaste|oncopy|oncut|onpaste|onsearch|onselectstart|previousElementSibling|\r\nnextElementSibling|children|firstElementChild|lastElementChild|childElementCount|\r\nonwebkitfullscreenchange|onwebkitfullscreenerror|setPointerCapture|releasePointerCapture|\r\nhasPointerCapture|hasAttributes|getAttributeNames|getAttribute|getAttributeNS|setAttribute|\r\nsetAttributeNS|removeAttribute|removeAttributeNS|hasAttribute|hasAttributeNS|getAttributeNode|\r\ngetAttributeNodeNS|setAttributeNode|setAttributeNodeNS|removeAttributeNode|closest|matches|\r\nwebkitMatchesSelector|attachShadow|getElementsByTagName|getElementsByTagNameNS|getElementsByClassName|\r\ninsertAdjacentElement|insertAdjacentText|insertAdjacentHTML|requestPointerLock|getClientRects|\r\ngetBoundingClientRect|scrollIntoView|scrollIntoViewIfNeeded|animate|before|after|replaceWith|remove|\r\nprepend|append|querySelector|querySelectorAll|webkitRequestFullScreen|webkitRequestFullscreen|attributeStyleMap|\r\nscroll|scrollTo|scrollBy|createShadowRoot|getDestinationInsertionPoints|computedStyleMap|ELEMENT_NODE|ATTRIBUTE_NODE|\r\nTEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|\r\nDOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|DOCUMENT_POSITION_DISCONNECTED|\r\nDOCUMENT_POSITION_PRECEDING|DOCUMENT_POSITION_FOLLOWING|DOCUMENT_POSITION_CONTAINS|\r\nDOCUMENT_POSITION_CONTAINED_BY|DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC|nodeType|nodeName\r\n|baseURI|isConnected|ownerDocument|parentNode|parentElement|childNodes|firstChild|lastChild\r\n|previousSibling|nextSibling|nodeValue|textContent|hasChildNodes|getRootNode|normalize\r\n|cloneNode|isEqualNode|isSameNode|compareDocumentPosition|contains|lookupPrefix|\r\nlookupNamespaceURI|isDefaultNamespace|insertBefore|appendChild|replaceChild|removeChild|addEventListener|removeEventListener|dispatchEvent\r\n</pre>\r\n\r\n\r\n光是第一层外层的属性打印出来就如此之多，可想而知，对比虚拟dom的几个属性，dom的操作比虚拟dom 所耗费的性能多得多。\r\nDOM 操作是“昂贵”的，js 运行效率高，所以我们尽量减少 DOM 操作，而不是“推倒重来”，项目越复杂，影响就越严重，所以使用 vdom 即可解决这个问题\r\n\r\n下面是html代码例子以及对应的虚拟dom结构。\r\n\r\n<pre>\r\nhtml代码：\r\n&lt;ul id=\'list\'&gt;\r\n  &lt;li class=\'item\'&gt;Item 1&lt;/li&gt;\r\n  &lt;li class=\'item\'&gt;Item 2&lt;/li&gt;\r\n  &lt;li class=\'item\'&gt;Item 3&lt;/li&gt;\r\n&lt;/ul&gt;\r\n\r\n对应的虚拟dom形式：\r\n {\r\n  tagName: \'ul\', // 节点标签名\r\n  props: { // DOM的属性，用一个对象存储键值对\r\n    id: \'list\'\r\n  },\r\n  children: [ // 该节点的子节点\r\n    {tagName: \'li\', props: {class: \'item\'}, children: [\"Item 1\"]},\r\n    {tagName: \'li\', props: {class: \'item\'}, children: [\"Item 2\"]},\r\n    {tagName: \'li\', props: {class: \'item\'}, children: [\"Item 3\"]},\r\n  ]\r\n}\r\n</pre>\r\n\r\nVirtual DOM 算法：包括几个步骤：\r\n用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中\r\n当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异\r\n把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了\r\n\r\n\r\n根据vdom的描述，下面使用jQuery来模拟实现上面的代码\r\n<pre>\r\nvar data = [\r\n            {\r\n                name: \'张三\',\r\n                age: \'20\',\r\n                address: \'北京\'\r\n            },\r\n            {\r\n                name: \'李四\',\r\n                age: \'21\',\r\n                address: \'上海\'\r\n            },\r\n            {\r\n                name: \'王五\',\r\n                age: \'22\',\r\n                address: \'广州\'\r\n            }\r\n        ]\r\n\r\n        // 渲染函数\r\n        function render(data) {\r\n            var $container = $(\'#container\')\r\n\r\n            // 清空容器，重要！！！\r\n            $container.html(\'\')\r\n\r\n            // 拼接 table\r\n            var $table = $(\'&lt;table&gt;\')\r\n\r\n            $table.append($(\'&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;address&lt;/td&gt;/tr&gt;\'))\r\n            data.forEach(function (item) {\r\n                $table.append($(\'&lt;tr&gt;&lt;td&gt;\' + item.name + \'&lt;/td&gt;&lt;td&gt;\' + item.age + \'&lt;/td&gt;&lt;td&gt;\' + item.address + \'&lt;/td&gt;/tr&gt;\'))\r\n            })\r\n\r\n            // 渲染到页面\r\n            $container.append($table)\r\n        }\r\n\r\n        $(\'#btn-change\').click(function () {\r\n            data[1].age = 30\r\n            data[2].address = \'深圳\'\r\n            // re-render  再次渲染\r\n            render(data)\r\n        })\r\n\r\n        // 页面加载完立刻执行（初次渲染）\r\n        render(data)\r\n\r\n</pre>\r\n\r\n但是这样每次也是重新渲染全部的dom元素，我们要的效果是将需要改变的元素进行更新，其他的保持不变，所以要进行优化，所以下面我们使用snabbdom进行优化。snabbdom使用的diff 算法进行比对，找出本次 DOM 必须更新的节点来更新，其他的不更新，从而优化渲染性能。\r\n更多api请移步github<a href=\"https://github.com/snabbdom/snabbdom\" rel=\"noopener\" target=\"_blank\">Snabbdom （ A virtual DOM library）</a>\r\n\r\n<pre>\r\n  var snabbdom = window.snabbdom\r\n        // 定义关键函数 patch\r\n        var patch = snabbdom.init([\r\n            snabbdom_class,\r\n            snabbdom_props,\r\n            snabbdom_style,\r\n            snabbdom_eventlisteners\r\n        ])\r\n\r\n        // 定义关键函数 h\r\n        var h = snabbdom.h\r\n\r\n        // 原始数据\r\n        var data = [\r\n            {\r\n                name: \'张三\',\r\n                age: \'20\',\r\n                address: \'北京\'\r\n            },\r\n            {\r\n                name: \'李四\',\r\n                age: \'21\',\r\n                address: \'上海\'\r\n            },\r\n            {\r\n                name: \'王五\',\r\n                age: \'22\',\r\n                address: \'广州\'\r\n            }\r\n        ]\r\n        // 把表头也放在 data 中\r\n        data.unshift({\r\n            name: \'姓名\',\r\n            age: \'年龄\',\r\n            address: \'地址\'\r\n        })\r\n\r\n        var container = document.getElementById(\'container\')\r\n\r\n        // 渲染函数\r\n        var vnode\r\n        function render(data) {\r\n            var newVnode = h(\'table\', {}, data.map(function (item) {\r\n                var tds = []\r\n                var i\r\n                for (i in item) {\r\n                    if (item.hasOwnProperty(i)) {\r\n                        tds.push(h(\'td\', {}, item[i] + \'\'))\r\n                    }\r\n                }\r\n                return h(\'tr\', {}, tds)\r\n            }))\r\n\r\n            if (vnode) {\r\n                // re-render\r\n                patch(vnode, newVnode)\r\n            } else {\r\n                // 初次渲染\r\n                patch(container, newVnode)\r\n            }\r\n\r\n            // 存储当前的 vnode 结果\r\n            vnode = newVnode\r\n        }\r\n\r\n        // 初次渲染\r\n        render(data)\r\n\r\n\r\n        var btnChange = document.getElementById(\'btn-change\')\r\n        btnChange.addEventListener(\'click\', function () {\r\n            data[1].age = 30\r\n            data[2].address = \'深圳\'\r\n            // re-render\r\n            render(data)\r\n        })\r\n</pre>\r\n\r\n使用控制台，调试下看到，点击change按钮进行改变，只是改变对应的元素而已，其他元素没有发生变化。\r\n\r\nVirtual DOM 算法：\r\n用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中\r\n当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异\r\n把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了\r\nsnabbdom使用diff 算法进行比对，找出本次 DOM 必须更新的节点来更新，其他的不更新，从而优化渲染性能。\r\n\r\nvdom diff算法最重要的两个api，一个是patch(container,vnode);一个是patch(vnode,newnode);\r\n下面我们通过js代码简单地模拟下两个实现,这是假设所有children都是tag的情况，当然实际情况比这复杂多了。\r\n\r\n<pre>\r\nfunction createElement(vnode) {\r\n    var tag = vnode.tag  // \'ul\'\r\n    var attrs = vnode.attrs || {}\r\n    var children = vnode.children || []\r\n    if (!tag) {\r\n        return null\r\n    }\r\n\r\n    // 创建真实的 DOM 元素\r\n    var elem = document.createElement(tag)\r\n    // 属性\r\n    var attrName\r\n    for (attrName in attrs) {\r\n        if (attrs.hasOwnProperty(attrName)) {\r\n            // 给 elem 添加属性\r\n            elem.setAttribute(attrName, attrs[attrName])\r\n        }\r\n    }\r\n    // 子元素\r\n    children.forEach(function (childVnode) {\r\n        // 给 elem 添加子元素\r\n        elem.appendChild(createElement(childVnode))  // 递归\r\n    })\r\n\r\n    // 返回真实的 DOM 元素\r\n    return elem\r\n}\r\n\r\n\r\nfunction updateChildren(vnode, newVnode) {\r\n    var children = vnode.children || []\r\n    var newChildren = newVnode.children || []\r\n\r\n    children.forEach(function (childVnode, index) {\r\n        var newChildVnode = newChildren[index]\r\n        if (childVnode.tag === newChildVnode.tag) {\r\n            // 深层次对比，递归\r\n            updateChildren(childVnode, newChildVnode)\r\n        } else {\r\n            // 替换\r\n            replaceNode(childVnode, newChildVnode)\r\n        }\r\n    })\r\n}\r\n\r\nfunction replaceNode(vnode, newVnode) {\r\n    var elem = vnode.elem  // 真实的 DOM 节点\r\n    var newElem = createElement(newVnode)\r\n\r\n    // 替换\r\n}\r\n</pre>\r\n\r\ndiff算法其实是linux的基础命令，vdom中应用diff算法是为了找出需要更新的节点，vdom的模拟简单实现有两个重要的api patch(container,vnode);一个是patch(vnode,newnode);\r\n\r\n我自己的理解\r\n\r\n虚拟dom：就是 通过js对象表示的DOM结构。\r\n\r\n尝试虚拟dom的原因：操作一次的dom的渲染成本远远超过与操作虚拟dom的成本，操作dom是最耗费性能的，所以通过将dom对比操作放在js层,提高效率，也就是虚拟dom。\r\n\r\n下面我们通过控制台打印来看一下，一个dom元素的复杂程度。\r\n<pre>\r\nvar div=document.createElement(\'div\')\r\nvar result=\'\'\r\n\r\nfor(let item in div){\r\nresult+=\'|\'+item;\r\n}\r\nconsole.log(result)\r\n\r\n//|align|title|lang|translate|dir|dataset|hidden|tabIndex|accessKey|draggable\r\n|spellcheck|autocapitalize|contentEditable|isContentEditable|offsetParent\r\n|offsetTop|offsetLeft|offsetWidth|offsetHeight|style|innerText|outerText\r\n|onabort|onblur|oncancel|oncanplay|oncanplaythrough|onchange|onclick|onclose\r\n|oncontextmenu|oncuechange|ondblclick|ondrag|ondragend|ondragenter|ondragleave\r\n|ondragover|ondragstart|ondrop|ondurationchange|onemptied|onended|onerror|onfocus\r\n|oninput|oninvalid|onkeydown|onkeypress|onkeyup|onload|onloadeddata|onloadedmetadata\r\n|onloadstart|onmousedown|onmouseenter|onmouseleave|onmousemove|onmouseout|onmouseover\r\n|onmouseup|onmousewheel|onpause|onplay|onplaying|onprogress|onratechange|onreset\r\n|onresize|onscroll|onseeked|onseeking|onselect|onstalled|onsubmit|onsuspend\r\n|ontimeupdate|ontoggle|onvolumechange|onwaiting|onwheel|onauxclick|ongotpointercapture|\r\nonlostpointercapture|onpointerdown|onpointermove|onpointerup|onpointercancel|\r\nonpointerover|onpointerout|onpointerenter|onpointerleave|nonce|click|focus|blur|\r\ninputMode|namespaceURI|prefix|localName|tagName|id|className|classList|slot|attributes|\r\nshadowRoot|assignedSlot|innerHTML|outerHTML|scrollTop|scrollLeft|scrollWidth|\r\nscrollHeight|clientTop|clientLeft|clientWidth|clientHeight|onbeforecopy|onbeforecut|\r\nonbeforepaste|oncopy|oncut|onpaste|onsearch|onselectstart|previousElementSibling|\r\nnextElementSibling|children|firstElementChild|lastElementChild|childElementCount|\r\nonwebkitfullscreenchange|onwebkitfullscreenerror|setPointerCapture|releasePointerCapture|\r\nhasPointerCapture|hasAttributes|getAttributeNames|getAttribute|getAttributeNS|setAttribute|\r\nsetAttributeNS|removeAttribute|removeAttributeNS|hasAttribute|hasAttributeNS|getAttributeNode|\r\ngetAttributeNodeNS|setAttributeNode|setAttributeNodeNS|removeAttributeNode|closest|matches|\r\nwebkitMatchesSelector|attachShadow|getElementsByTagName|getElementsByTagNameNS|getElementsByClassName|\r\ninsertAdjacentElement|insertAdjacentText|insertAdjacentHTML|requestPointerLock|getClientRects|\r\ngetBoundingClientRect|scrollIntoView|scrollIntoViewIfNeeded|animate|before|after|replaceWith|remove|\r\nprepend|append|querySelector|querySelectorAll|webkitRequestFullScreen|webkitRequestFullscreen|attributeStyleMap|\r\nscroll|scrollTo|scrollBy|createShadowRoot|getDestinationInsertionPoints|computedStyleMap|ELEMENT_NODE|ATTRIBUTE_NODE|\r\nTEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|\r\nDOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|DOCUMENT_POSITION_DISCONNECTED|\r\nDOCUMENT_POSITION_PRECEDING|DOCUMENT_POSITION_FOLLOWING|DOCUMENT_POSITION_CONTAINS|\r\nDOCUMENT_POSITION_CONTAINED_BY|DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC|nodeType|nodeName\r\n|baseURI|isConnected|ownerDocument|parentNode|parentElement|childNodes|firstChild|lastChild\r\n|previousSibling|nextSibling|nodeValue|textContent|hasChildNodes|getRootNode|normalize\r\n|cloneNode|isEqualNode|isSameNode|compareDocumentPosition|contains|lookupPrefix|\r\nlookupNamespaceURI|isDefaultNamespace|insertBefore|appendChild|replaceChild|removeChild|addEventListener|removeEventListener|dispatchEvent\r\n</pre>\r\n\r\n\r\n光是第一层外层的属性打印出来就如此之多，可想而知，对比虚拟dom的几个属性，dom的操作比虚拟dom 所耗费的性能多得多。\r\nDOM 操作是“昂贵”的，js 运行效率高，所以我们尽量减少 DOM 操作，而不是“推倒重来”，项目越复杂，影响就越严重，所以使用 vdom 即可解决这个问题\r\n\r\n下面是html代码例子以及对应的虚拟dom结构。\r\n\r\n<pre>\r\nhtml代码：\r\n&lt;ul id=\'list\'&gt;\r\n  &lt;li class=\'item\'&gt;Item 1&lt;/li&gt;\r\n  &lt;li class=\'item\'&gt;Item 2&lt;/li&gt;\r\n  &lt;li class=\'item\'&gt;Item 3&lt;/li&gt;\r\n&lt;/ul&gt;\r\n\r\n对应的虚拟dom形式：\r\n {\r\n  tagName: \'ul\', // 节点标签名\r\n  props: { // DOM的属性，用一个对象存储键值对\r\n    id: \'list\'\r\n  },\r\n  children: [ // 该节点的子节点\r\n    {tagName: \'li\', props: {class: \'item\'}, children: [\"Item 1\"]},\r\n    {tagName: \'li\', props: {class: \'item\'}, children: [\"Item 2\"]},\r\n    {tagName: \'li\', props: {class: \'item\'}, children: [\"Item 3\"]},\r\n  ]\r\n}\r\n</pre>\r\n\r\nVirtual DOM 算法：包括几个步骤：\r\n用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中\r\n当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异\r\n把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了\r\n\r\n\r\n根据vdom的描述，下面使用jQuery来模拟实现上面的代码\r\n<pre>\r\nvar data = [\r\n            {\r\n                name: \'张三\',\r\n                age: \'20\',\r\n                address: \'北京\'\r\n            },\r\n            {\r\n                name: \'李四\',\r\n                age: \'21\',\r\n                address: \'上海\'\r\n            },\r\n            {\r\n                name: \'王五\',\r\n                age: \'22\',\r\n                address: \'广州\'\r\n            }\r\n        ]\r\n\r\n        // 渲染函数\r\n        function render(data) {\r\n            var $container = $(\'#container\')\r\n\r\n            // 清空容器，重要！！！\r\n            $container.html(\'\')\r\n\r\n            // 拼接 table\r\n            var $table = $(\'&lt;table&gt;\')\r\n\r\n            $table.append($(\'&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;address&lt;/td&gt;/tr&gt;\'))\r\n            data.forEach(function (item) {\r\n                $table.append($(\'&lt;tr&gt;&lt;td&gt;\' + item.name + \'&lt;/td&gt;&lt;td&gt;\' + item.age + \'&lt;/td&gt;&lt;td&gt;\' + item.address + \'&lt;/td&gt;/tr&gt;\'))\r\n            })\r\n\r\n            // 渲染到页面\r\n            $container.append($table)\r\n        }\r\n\r\n        $(\'#btn-change\').click(function () {\r\n            data[1].age = 30\r\n            data[2].address = \'深圳\'\r\n            // re-render  再次渲染\r\n            render(data)\r\n        })\r\n\r\n        // 页面加载完立刻执行（初次渲染）\r\n        render(data)\r\n\r\n</pre>\r\n\r\n但是这样每次也是重新渲染全部的dom元素，我们要的效果是将需要改变的元素进行更新，其他的保持不变，所以要进行优化，所以下面我们使用snabbdom进行优化。snabbdom使用的diff 算法进行比对，找出本次 DOM 必须更新的节点来更新，其他的不更新，从而优化渲染性能。\r\n更多api请移步github<a href=\"https://github.com/snabbdom/snabbdom\" rel=\"noopener\" target=\"_blank\">Snabbdom （ A virtual DOM library）</a>\r\n\r\n<pre>\r\n  var snabbdom = window.snabbdom\r\n        // 定义关键函数 patch\r\n        var patch = snabbdom.init([\r\n            snabbdom_class,\r\n            snabbdom_props,\r\n            snabbdom_style,\r\n            snabbdom_eventlisteners\r\n        ])\r\n\r\n        // 定义关键函数 h\r\n        var h = snabbdom.h\r\n\r\n        // 原始数据\r\n        var data = [\r\n            {\r\n                name: \'张三\',\r\n                age: \'20\',\r\n                address: \'北京\'\r\n            },\r\n            {\r\n                name: \'李四\',\r\n                age: \'21\',\r\n                address: \'上海\'\r\n            },\r\n            {\r\n                name: \'王五\',\r\n                age: \'22\',\r\n                address: \'广州\'\r\n            }\r\n        ]\r\n        // 把表头也放在 data 中\r\n        data.unshift({\r\n            name: \'姓名\',\r\n            age: \'年龄\',\r\n            address: \'地址\'\r\n        })\r\n\r\n        var container = document.getElementById(\'container\')\r\n\r\n        // 渲染函数\r\n        var vnode\r\n        function render(data) {\r\n            var newVnode = h(\'table\', {}, data.map(function (item) {\r\n                var tds = []\r\n                var i\r\n                for (i in item) {\r\n                    if (item.hasOwnProperty(i)) {\r\n                        tds.push(h(\'td\', {}, item[i] + \'\'))\r\n                    }\r\n                }\r\n                return h(\'tr\', {}, tds)\r\n            }))\r\n\r\n            if (vnode) {\r\n                // re-render\r\n                patch(vnode, newVnode)\r\n            } else {\r\n                // 初次渲染\r\n                patch(container, newVnode)\r\n            }\r\n\r\n            // 存储当前的 vnode 结果\r\n            vnode = newVnode\r\n        }\r\n\r\n        // 初次渲染\r\n        render(data)\r\n\r\n\r\n        var btnChange = document.getElementById(\'btn-change\')\r\n        btnChange.addEventListener(\'click\', function () {\r\n            data[1].age = 30\r\n            data[2].address = \'深圳\'\r\n            // re-render\r\n            render(data)\r\n        })\r\n</pre>\r\n\r\n使用控制台，调试下看到，点击change按钮进行改变，只是改变对应的元素而已，其他元素没有发生变化。\r\n\r\nVirtual DOM 算法：\r\n用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中\r\n当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异\r\n把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了\r\nsnabbdom使用diff 算法进行比对，找出本次 DOM 必须更新的节点来更新，其他的不更新，从而优化渲染性能。\r\n\r\nvdom diff算法最重要的两个api，一个是patch(container,vnode);一个是patch(vnode,newnode);\r\n下面我们通过js代码简单地模拟下两个实现,这是假设所有children都是tag的情况，当然实际情况比这复杂多了。\r\n\r\n<pre>\r\nfunction createElement(vnode) {\r\n    var tag = vnode.tag  // \'ul\'\r\n    var attrs = vnode.attrs || {}\r\n    var children = vnode.children || []\r\n    if (!tag) {\r\n        return null\r\n    }\r\n\r\n    // 创建真实的 DOM 元素\r\n    var elem = document.createElement(tag)\r\n    // 属性\r\n    var attrName\r\n    for (attrName in attrs) {\r\n        if (attrs.hasOwnProperty(attrName)) {\r\n            // 给 elem 添加属性\r\n            elem.setAttribute(attrName, attrs[attrName])\r\n        }\r\n    }\r\n    // 子元素\r\n    children.forEach(function (childVnode) {\r\n        // 给 elem 添加子元素\r\n        elem.appendChild(createElement(childVnode))  // 递归\r\n    })\r\n\r\n    // 返回真实的 DOM 元素\r\n    return elem\r\n}\r\n\r\n\r\nfunction updateChildren(vnode, newVnode) {\r\n    var children = vnode.children || []\r\n    var newChildren = newVnode.children || []\r\n\r\n    children.forEach(function (childVnode, index) {\r\n        var newChildVnode = newChildren[index]\r\n        if (childVnode.tag === newChildVnode.tag) {\r\n            // 深层次对比，递归\r\n            updateChildren(childVnode, newChildVnode)\r\n        } else {\r\n            // 替换\r\n            replaceNode(childVnode, newChildVnode)\r\n        }\r\n    })\r\n}\r\n\r\nfunction replaceNode(vnode, newVnode) {\r\n    var elem = vnode.elem  // 真实的 DOM 节点\r\n    var newElem = createElement(newVnode)\r\n\r\n    // 替换\r\n}\r\n</pre>\r\n\r\ndiff算法其实是linux的基础命令，vdom中应用diff算法是为了找出需要更新的节点，vdom的模拟简单实现有两个重要的api patch(container,vnode);一个是patch(vnode,newnode);\r\n\r\n我自己的理解\r\n\r\n虚拟dom：就是 通过js对象表示的DOM结构。\r\n\r\n尝试虚拟dom的原因：操作一次的dom的渲染成本远远超过与操作虚拟dom的成本，操作dom是最耗费性能的，所以通过将dom对比操作放在js层,提高效率，也就是虚拟dom。\r\n\r\n下面我们通过控制台打印来看一下，一个dom元素的复杂程度。\r\n<pre>\r\nvar div=document.createElement(\'div\')\r\nvar result=\'\'\r\n\r\nfor(let item in div){\r\nresult+=\'|\'+item;\r\n}\r\nconsole.log(result)\r\n\r\n//|align|title|lang|translate|dir|dataset|hidden|tabIndex|accessKey|draggable\r\n|spellcheck|autocapitalize|contentEditable|isContentEditable|offsetParent\r\n|offsetTop|offsetLeft|offsetWidth|offsetHeight|style|innerText|outerText\r\n|onabort|onblur|oncancel|oncanplay|oncanplaythrough|onchange|onclick|onclose\r\n|oncontextmenu|oncuechange|ondblclick|ondrag|ondragend|ondragenter|ondragleave\r\n|ondragover|ondragstart|ondrop|ondurationchange|onemptied|onended|onerror|onfocus\r\n|oninput|oninvalid|onkeydown|onkeypress|onkeyup|onload|onloadeddata|onloadedmetadata\r\n|onloadstart|onmousedown|onmouseenter|onmouseleave|onmousemove|onmouseout|onmouseover\r\n|onmouseup|onmousewheel|onpause|onplay|onplaying|onprogress|onratechange|onreset\r\n|onresize|onscroll|onseeked|onseeking|onselect|onstalled|onsubmit|onsuspend\r\n|ontimeupdate|ontoggle|onvolumechange|onwaiting|onwheel|onauxclick|ongotpointercapture|\r\nonlostpointercapture|onpointerdown|onpointermove|onpointerup|onpointercancel|\r\nonpointerover|onpointerout|onpointerenter|onpointerleave|nonce|click|focus|blur|\r\ninputMode|namespaceURI|prefix|localName|tagName|id|className|classList|slot|attributes|\r\nshadowRoot|assignedSlot|innerHTML|outerHTML|scrollTop|scrollLeft|scrollWidth|\r\nscrollHeight|clientTop|clientLeft|clientWidth|clientHeight|onbeforecopy|onbeforecut|\r\nonbeforepaste|oncopy|oncut|onpaste|onsearch|onselectstart|previousElementSibling|\r\nnextElementSibling|children|firstElementChild|lastElementChild|childElementCount|\r\nonwebkitfullscreenchange|onwebkitfullscreenerror|setPointerCapture|releasePointerCapture|\r\nhasPointerCapture|hasAttributes|getAttributeNames|getAttribute|getAttributeNS|setAttribute|\r\nsetAttributeNS|removeAttribute|removeAttributeNS|hasAttribute|hasAttributeNS|getAttributeNode|\r\ngetAttributeNodeNS|setAttributeNode|setAttributeNodeNS|removeAttributeNode|closest|matches|\r\nwebkitMatchesSelector|attachShadow|getElementsByTagName|getElementsByTagNameNS|getElementsByClassName|\r\ninsertAdjacentElement|insertAdjacentText|insertAdjacentHTML|requestPointerLock|getClientRects|\r\ngetBoundingClientRect|scrollIntoView|scrollIntoViewIfNeeded|animate|before|after|replaceWith|remove|\r\nprepend|append|querySelector|querySelectorAll|webkitRequestFullScreen|webkitRequestFullscreen|attributeStyleMap|\r\nscroll|scrollTo|scrollBy|createShadowRoot|getDestinationInsertionPoints|computedStyleMap|ELEMENT_NODE|ATTRIBUTE_NODE|\r\nTEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|\r\nDOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|DOCUMENT_POSITION_DISCONNECTED|\r\nDOCUMENT_POSITION_PRECEDING|DOCUMENT_POSITION_FOLLOWING|DOCUMENT_POSITION_CONTAINS|\r\nDOCUMENT_POSITION_CONTAINED_BY|DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC|nodeType|nodeName\r\n|baseURI|isConnected|ownerDocument|parentNode|parentElement|childNodes|firstChild|lastChild\r\n|previousSibling|nextSibling|nodeValue|textContent|hasChildNodes|getRootNode|normalize\r\n|cloneNode|isEqualNode|isSameNode|compareDocumentPosition|contains|lookupPrefix|\r\nlookupNamespaceURI|isDefaultNamespace|insertBefore|appendChild|replaceChild|removeChild|addEventListener|removeEventListener|dispatchEvent\r\n</pre>\r\n\r\n\r\n光是第一层外层的属性打印出来就如此之多，可想而知，对比虚拟dom的几个属性，dom的操作比虚拟dom 所耗费的性能多得多。\r\nDOM 操作是“昂贵”的，js 运行效率高，所以我们尽量减少 DOM 操作，而不是“推倒重来”，项目越复杂，影响就越严重，所以使用 vdom 即可解决这个问题\r\n\r\n下面是html代码例子以及对应的虚拟dom结构。\r\n\r\n<pre>\r\nhtml代码：\r\n&lt;ul id=\'list\'&gt;\r\n  &lt;li class=\'item\'&gt;Item 1&lt;/li&gt;\r\n  &lt;li class=\'item\'&gt;Item 2&lt;/li&gt;\r\n  &lt;li class=\'item\'&gt;Item 3&lt;/li&gt;\r\n&lt;/ul&gt;\r\n\r\n对应的虚拟dom形式：\r\n {\r\n  tagName: \'ul\', // 节点标签名\r\n  props: { // DOM的属性，用一个对象存储键值对\r\n    id: \'list\'\r\n  },\r\n  children: [ // 该节点的子节点\r\n    {tagName: \'li\', props: {class: \'item\'}, children: [\"Item 1\"]},\r\n    {tagName: \'li\', props: {class: \'item\'}, children: [\"Item 2\"]},\r\n    {tagName: \'li\', props: {class: \'item\'}, children: [\"Item 3\"]},\r\n  ]\r\n}\r\n</pre>\r\n\r\nVirtual DOM 算法：包括几个步骤：\r\n用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中\r\n当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异\r\n把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了\r\n\r\n\r\n根据vdom的描述，下面使用jQuery来模拟实现上面的代码\r\n<pre>\r\nvar data = [\r\n            {\r\n                name: \'张三\',\r\n                age: \'20\',\r\n                address: \'北京\'\r\n            },\r\n            {\r\n                name: \'李四\',\r\n                age: \'21\',\r\n                address: \'上海\'\r\n            },\r\n            {\r\n                name: \'王五\',\r\n                age: \'22\',\r\n                address: \'广州\'\r\n            }\r\n        ]\r\n\r\n        // 渲染函数\r\n        function render(data) {\r\n            var $container = $(\'#container\')\r\n\r\n            // 清空容器，重要！！！\r\n            $container.html(\'\')\r\n\r\n            // 拼接 table\r\n            var $table = $(\'&lt;table&gt;\')\r\n\r\n            $table.append($(\'&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;address&lt;/td&gt;/tr&gt;\'))\r\n            data.forEach(function (item) {\r\n                $table.append($(\'&lt;tr&gt;&lt;td&gt;\' + item.name + \'&lt;/td&gt;&lt;td&gt;\' + item.age + \'&lt;/td&gt;&lt;td&gt;\' + item.address + \'&lt;/td&gt;/tr&gt;\'))\r\n            })\r\n\r\n            // 渲染到页面\r\n            $container.append($table)\r\n        }\r\n\r\n        $(\'#btn-change\').click(function () {\r\n            data[1].age = 30\r\n            data[2].address = \'深圳\'\r\n            // re-render  再次渲染\r\n            render(data)\r\n        })\r\n\r\n        // 页面加载完立刻执行（初次渲染）\r\n        render(data)\r\n\r\n</pre>\r\n\r\n但是这样每次也是重新渲染全部的dom元素，我们要的效果是将需要改变的元素进行更新，其他的保持不变，所以要进行优化，所以下面我们使用snabbdom进行优化。snabbdom使用的diff 算法进行比对，找出本次 DOM 必须更新的节点来更新，其他的不更新，从而优化渲染性能。\r\n更多api请移步github<a href=\"https://github.com/snabbdom/snabbdom\" rel=\"noopener\" target=\"_blank\">Snabbdom （ A virtual DOM library）</a>\r\n\r\n<pre>\r\n  var snabbdom = window.snabbdom\r\n        // 定义关键函数 patch\r\n        var patch = snabbdom.init([\r\n            snabbdom_class,\r\n            snabbdom_props,\r\n            snabbdom_style,\r\n            snabbdom_eventlisteners\r\n        ])\r\n\r\n        // 定义关键函数 h\r\n        var h = snabbdom.h\r\n\r\n        // 原始数据\r\n        var data = [\r\n            {\r\n                name: \'张三\',\r\n                age: \'20\',\r\n                address: \'北京\'\r\n            },\r\n            {\r\n                name: \'李四\',\r\n                age: \'21\',\r\n                address: \'上海\'\r\n            },\r\n            {\r\n                name: \'王五\',\r\n                age: \'22\',\r\n                address: \'广州\'\r\n            }\r\n        ]\r\n        // 把表头也放在 data 中\r\n        data.unshift({\r\n            name: \'姓名\',\r\n            age: \'年龄\',\r\n            address: \'地址\'\r\n        })\r\n\r\n        var container = document.getElementById(\'container\')\r\n\r\n        // 渲染函数\r\n        var vnode\r\n        function render(data) {\r\n            var newVnode = h(\'table\', {}, data.map(function (item) {\r\n                var tds = []\r\n                var i\r\n                for (i in item) {\r\n                    if (item.hasOwnProperty(i)) {\r\n                        tds.push(h(\'td\', {}, item[i] + \'\'))\r\n                    }\r\n                }\r\n                return h(\'tr\', {}, tds)\r\n            }))\r\n\r\n            if (vnode) {\r\n                // re-render\r\n                patch(vnode, newVnode)\r\n            } else {\r\n                // 初次渲染\r\n                patch(container, newVnode)\r\n            }\r\n\r\n            // 存储当前的 vnode 结果\r\n            vnode = newVnode\r\n        }\r\n\r\n        // 初次渲染\r\n        render(data)\r\n\r\n\r\n        var btnChange = document.getElementById(\'btn-change\')\r\n        btnChange.addEventListener(\'click\', function () {\r\n            data[1].age = 30\r\n            data[2].address = \'深圳\'\r\n            // re-render\r\n            render(data)\r\n        })\r\n</pre>\r\n\r\n使用控制台，调试下看到，点击change按钮进行改变，只是改变对应的元素而已，其他元素没有发生变化。\r\n\r\nVirtual DOM 算法：\r\n用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中\r\n当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异\r\n把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了\r\nsnabbdom使用diff 算法进行比对，找出本次 DOM 必须更新的节点来更新，其他的不更新，从而优化渲染性能。\r\n\r\nvdom diff算法最重要的两个api，一个是patch(container,vnode);一个是patch(vnode,newnode);\r\n下面我们通过js代码简单地模拟下两个实现,这是假设所有children都是tag的情况，当然实际情况比这复杂多了。\r\n\r\n<pre>\r\nfunction createElement(vnode) {\r\n    var tag = vnode.tag  // \'ul\'\r\n    var attrs = vnode.attrs || {}\r\n    var children = vnode.children || []\r\n    if (!tag) {\r\n        return null\r\n    }\r\n\r\n    // 创建真实的 DOM 元素\r\n    var elem = document.createElement(tag)\r\n    // 属性\r\n    var attrName\r\n    for (attrName in attrs) {\r\n        if (attrs.hasOwnProperty(attrName)) {\r\n            // 给 elem 添加属性\r\n            elem.setAttribute(attrName, attrs[attrName])\r\n        }\r\n    }\r\n    // 子元素\r\n    children.forEach(function (childVnode) {\r\n        // 给 elem 添加子元素\r\n        elem.appendChild(createElement(childVnode))  // 递归\r\n    })\r\n\r\n    // 返回真实的 DOM 元素\r\n    return elem\r\n}\r\n\r\n\r\nfunction updateChildren(vnode, newVnode) {\r\n    var children = vnode.children || []\r\n    var newChildren = newVnode.children || []\r\n\r\n    children.forEach(function (childVnode, index) {\r\n        var newChildVnode = newChildren[index]\r\n        if (childVnode.tag === newChildVnode.tag) {\r\n            // 深层次对比，递归\r\n            updateChildren(childVnode, newChildVnode)\r\n        } else {\r\n            // 替换\r\n            replaceNode(childVnode, newChildVnode)\r\n        }\r\n    })\r\n}\r\n\r\nfunction replaceNode(vnode, newVnode) {\r\n    var elem = vnode.elem  // 真实的 DOM 节点\r\n    var newElem = createElement(newVnode)\r\n\r\n    // 替换\r\n}\r\n</pre>\r\n\r\ndiff算法其实是linux的基础命令，vdom中应用diff算法是为了找出需要更新的节点，vdom的模拟简单实现有两个重要的api patch(container,vnode);一个是patch(vnode,newnode);\r\n\r\n', '4', '2018-09-30 09:34:19', '2018-09-30 09:34:23');
INSERT INTO `content` VALUES ('5', '<p>啊实打实大爱上爱上</p>', '8', '2018-10-02 09:14:35', '2018-10-02 09:14:35');
INSERT INTO `content` VALUES ('6', '<p>啊实打实大爱上爱上</p>', '9', '2018-10-02 09:19:04', '2018-10-02 09:19:04');
INSERT INTO `content` VALUES ('7', '<p>认真地学习</p>', '10', '2018-10-02 09:27:55', '2018-10-02 09:27:55');
INSERT INTO `content` VALUES ('8', '<p>啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿啊实打<span style=\"color: rgb(249, 150, 59);\">实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德<span style=\"font-weight: bold;\"></span>萨德爱上爱上啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打</span>实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德<span style=\"background-color: rgb(70, 172, 200);\">阿萨啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿</span>萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德啊实打实大阿萨德爱上爱上阿萨德阿萨德</p>', '11', '2018-10-02 09:29:55', '2018-10-02 09:29:55');
INSERT INTO `content` VALUES ('9', '<p>我们要努力地学习&nbsp;&nbsp;&nbsp;&nbsp;</p>', '12', '2018-10-03 14:08:10', '2018-10-03 14:08:10');
INSERT INTO `content` VALUES ('10', '<strong>1.使用apply实现拼接</strong>\r\n<pre>var arr=[1,2,3]\r\nvar temp=[4,5,6]\r\narr.push.apply(arr,temp)\r\n</pre>\r\n<strong>2.set数组去重</strong>\r\n<pre>[...new Set([1,2,3,1,2,1,1,1,1,1])]\r\n</pre>\r\n<strong>3.求最大项</strong>\r\n<pre>Math.max(...[1,2,3,1,2,1,1,1,1,1]);\r\n</pre>\r\n<strong>4.位运算符判断indexOf是否等于-1</strong>\r\n<pre>if(!~arr.indexOf(item)){\r\n 如果ite不存在于数组，就...\r\n}\r\n</pre>\r\n<strong>5.前端错误记录到后端\r\n</strong>\r\n<pre>function logError(sev, msg){\r\n        var img = new Image();\r\n        img.src = \"log.php?sev=\" + encodeURIComponent(sev) + \"&amp;msg=\" +\r\n                  encodeURIComponent(msg);\r\n}\r\n</pre>\r\n（持续收集中....欢迎添砖加瓦）', '13', '2018-10-03 14:13:06', '2018-10-03 14:13:06');
INSERT INTO `content` VALUES ('11', '<pre><code>&lt;strong&gt;1.使用apply实现拼接&lt;/strong&gt;<br>&lt;pre&gt;var arr=[1,2,3]<br>var temp=[4,5,6]<br>arr.push.apply(arr,temp)<br>&lt;/pre&gt;<br>&lt;strong&gt;2.set数组去重&lt;/strong&gt;<br>&lt;pre&gt;[...new Set([1,2,3,1,2,1,1,1,1,1])]<br>&lt;/pre&gt;<br>&lt;strong&gt;3.求最大项&lt;/strong&gt;<br>&lt;pre&gt;Math.max(...[1,2,3,1,2,1,1,1,1,1]);<br>&lt;/pre&gt;<br>&lt;strong&gt;4.位运算符判断indexOf是否等于-1&lt;/strong&gt;<br>&lt;pre&gt;if(!~arr.indexOf(item)){<br> 如果ite不存在于数组，就...<br>}<br>&lt;/pre&gt;<br>&lt;strong&gt;5.前端错误记录到后端<br>&lt;/strong&gt;<br>&lt;pre&gt;function logError(sev, msg){<br>        var img = new Image();<br>        img.src = \"log.php?sev=\" + encodeURIComponent(sev) + \"&amp;msg=\" +<br>                  encodeURIComponent(msg);<br>}<br>&lt;/pre&gt;<br>（持续收集中....欢迎添砖加瓦）</code></pre><p><br></p>', '14', '2018-10-03 14:19:38', '2018-10-03 14:19:38');
INSERT INTO `content` VALUES ('12', '<pre><code>啊实打实大</code></pre><p><span style=\"font-family: Verdana;\">总结一些比较有趣的js代码总结一些比较有趣的js代码总结一些比较总结一些比较有趣的js代码总结一些比较有趣的js代码总结一些比较有趣的js代码总结一些比较有趣的js代码总结一些比较有趣的js代码总结一些比较有趣的js代码总结一些比较有趣的js代码总结一些总结一些<span style=\"color: rgb(249, 150, 59);\">比较有趣的js代码总结一些比较有趣的js</span>代码总结一些比较有趣的js代码总结一些比较有趣的js代码总结一些比较有趣的js代码总结一些比较有趣的js代码比较有趣的js代码总结一些比较有趣的js代码<span style=\"font-weight: bold;\"></span>有趣的js代</span>码总结一些比较有趣的js代码总<span style=\"color: rgb(249, 150, 59);\">结一些比较有趣的js代码总结一些比较有趣的js代码总结一些比较有趣的js</span>代码</p>', '15', '2018-10-03 14:20:53', '2018-10-03 14:20:53');
INSERT INTO `content` VALUES ('13', '<pre>\r\n例子：\r\n普通函数\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\nfoo函数只是一个普通函数，但是当用new来创建对象的时候，foo就是构造函数了。\r\n\r\n <strong>prototype</strong>\r\n\r\n该函数有一个prototype属性，指向了一个对象，该对象是调用该构造函数创建的<strong>实例</strong>的原型\r\n\r\n例如这里，foo.prototype 是 test的原型\r\n\r\n什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，\r\n这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\r\n\r\n<strong>__proto__</strong>\r\n\r\n每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。\r\n所以在上面的例子中，obj的__proto__等于foo.prototype\r\nconsole.log(test.__proto__===foo.prototype) //true\r\n\r\n<strong>constructor</strong>\r\n\r\n每个原型都有一个 constructor 属性指向关联的构造函数。\r\nconsole.log(foo === foo.prototype.constructor); // true\r\n\r\n所以综上例子：\r\n\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\nconsole.log(test.__proto__ == foo.prototype) // true\r\nconsole.log(foo.prototype.constructor == foo) // true\r\n\r\n那么就会有一个疑问了，对象的原型是构造它的函数的prototype指向的对象，那么构造函数的prototype指向的对象是什么？\r\nconsole.log(foo.prototype.__proto___===Object.prototype) //true\r\n没错，通过比较我们知道，foo的prototype属性指向的对象的原型是 Object构造函数的prototype属性指向的对象 \r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\n还是这张图，很明显了~然后Object.prototype.contructor === Object \r\n\r\n都是类似与foo的形式，一层继承一层，这就是原型链，那么最终Obejct.prototype.__proto__是什么呢 是null，只有null没有任何属性了。\r\n\r\n对于这个例子\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\nvar obj=new foo(2,3);\r\n我们可以通过在test对象的原型上设置属性，从而变相地实现提供公有属性跟方法，从而来优化代码。\r\n增加一下代码：\r\nfoo.prototype.setName=function(name){this.name=name};\r\ntest.setName(\'jgchen\');\r\nconsole.log(test.name) //jgchen\r\nobj.setName(\'jgchenuu\');\r\nconsole.log(obj.name) //jgchenuu\r\n\r\n\r\n然后还可以设置公有属性，\r\nfoo.prototype.type=\'guang\';\r\nconsole.log(obj.type);//\'guang\'\r\nconsole.log(test.type);//\'guang\'\r\n\r\n当然这么设计类似于继承的方式是有缺陷的，关于原型链的继承方面，请移步另外一篇文章 <a href=\"http://jgchen.xin/index.php/2018/05/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD-es5%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/\" rel=\"noopener\" target=\"_blank\">前端面试中-es5原型链实现类与继承的几种方法</a>\r\n\r\n\r\n</pre>\r\n\r\n<pre>\r\n例子：\r\n普通函数\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\nfoo函数只是一个普通函数，但是当用new来创建对象的时候，foo就是构造函数了。\r\n\r\n <strong>prototype</strong>\r\n\r\n该函数有一个prototype属性，指向了一个对象，该对象是调用该构造函数创建的<strong>实例</strong>的原型\r\n\r\n例如这里，foo.prototype 是 test的原型\r\n\r\n什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，\r\n这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\r\n\r\n<strong>__proto__</strong>\r\n\r\n每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。\r\n所以在上面的例子中，obj的__proto__等于foo.prototype\r\nconsole.log(test.__proto__===foo.prototype) //true\r\n\r\n<strong>constructor</strong>\r\n\r\n每个原型都有一个 constructor 属性指向关联的构造函数。\r\nconsole.log(foo === foo.prototype.constructor); // true\r\n\r\n所以综上例子：\r\n\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\nconsole.log(test.__proto__ == foo.prototype) // true\r\nconsole.log(foo.prototype.constructor == foo) // true\r\n\r\n那么就会有一个疑问了，对象的原型是构造它的函数的prototype指向的对象，那么构造函数的prototype指向的对象是什么？\r\nconsole.log(foo.prototype.__proto___===Object.prototype) //true\r\n没错，通过比较我们知道，foo的prototype属性指向的对象的原型是 Object构造函数的prototype属性指向的对象 \r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\n还是这张图，很明显了~然后Object.prototype.contructor === Object \r\n\r\n都是类似与foo的形式，一层继承一层，这就是原型链，那么最终Obejct.prototype.__proto__是什么呢 是null，只有null没有任何属性了。\r\n\r\n对于这个例子\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\nvar obj=new foo(2,3);\r\n我们可以通过在test对象的原型上设置属性，从而变相地实现提供公有属性跟方法，从而来优化代码。\r\n增加一下代码：\r\nfoo.prototype.setName=function(name){this.name=name};\r\ntest.setName(\'jgchen\');\r\nconsole.log(test.name) //jgchen\r\nobj.setName(\'jgchenuu\');\r\nconsole.log(obj.name) //jgchenuu\r\n\r\n\r\n然后还可以设置公有属性，\r\nfoo.prototype.type=\'guang\';\r\nconsole.log(obj.type);//\'guang\'\r\nconsole.log(test.type);//\'guang\'\r\n\r\n当然这么设计类似于继承的方式是有缺陷的，关于原型链的继承方面，请移步另外一篇文章 <a href=\"http://jgchen.xin/index.php/2018/05/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD-es5%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/\" rel=\"noopener\" target=\"_blank\">前端面试中-es5原型链实现类与继承的几种方法</a>\r\n\r\n\r\n</pre>\r\n\r\n', '16', '2018-10-03 14:22:53', '2018-10-03 14:22:53');
INSERT INTO `content` VALUES ('14', '<pre>\r\n例子：\r\n普通函数\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\nfoo函数只是一个普通函数，但是当用new来创建对象的时候，foo就是构造函数了。\r\n\r\n <strong>prototype</strong>\r\n\r\n该函数有一个prototype属性，指向了一个对象，该对象是调用该构造函数创建的<strong>实例</strong>的原型\r\n\r\n例如这里，foo.prototype 是 test的原型\r\n\r\n什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，\r\n这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\r\n\r\n<strong>__proto__</strong>\r\n\r\n每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。\r\n所以在上面的例子中，obj的__proto__等于foo.prototype\r\nconsole.log(test.__proto__===foo.prototype) //true\r\n\r\n<strong>constructor</strong>\r\n\r\n每个原型都有一个 constructor 属性指向关联的构造函数。\r\nconsole.log(foo === foo.prototype.constructor); // true\r\n\r\n所以综上例子：\r\n\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\nconsole.log(test.__proto__ == foo.prototype) // true\r\nconsole.log(foo.prototype.constructor == foo) // true\r\n\r\n那么就会有一个疑问了，对象的原型是构造它的函数的prototype指向的对象，那么构造函数的prototype指向的对象是什么？\r\nconsole.log(foo.prototype.__proto___===Object.prototype) //true\r\n没错，通过比较我们知道，foo的prototype属性指向的对象的原型是 Object构造函数的prototype属性指向的对象 \r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\n还是这张图，很明显了~然后Object.prototype.contructor === Object \r\n\r\n都是类似与foo的形式，一层继承一层，这就是原型链，那么最终Obejct.prototype.__proto__是什么呢 是null，只有null没有任何属性了。\r\n\r\n对于这个例子\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\nvar obj=new foo(2,3);\r\n我们可以通过在test对象的原型上设置属性，从而变相地实现提供公有属性跟方法，从而来优化代码。\r\n增加一下代码：\r\nfoo.prototype.setName=function(name){this.name=name};\r\ntest.setName(\'jgchen\');\r\nconsole.log(test.name) //jgchen\r\nobj.setName(\'jgchenuu\');\r\nconsole.log(obj.name) //jgchenuu\r\n\r\n\r\n然后还可以设置公有属性，\r\nfoo.prototype.type=\'guang\';\r\nconsole.log(obj.type);//\'guang\'\r\nconsole.log(test.type);//\'guang\'\r\n\r\n当然这么设计类似于继承的方式是有缺陷的，关于原型链的继承方面，请移步另外一篇文章 <a href=\"http://jgchen.xin/index.php/2018/05/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD-es5%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/\" rel=\"noopener\" target=\"_blank\">前端面试中-es5原型链实现类与继承的几种方法</a>\r\n\r\n\r\n</pre>\r\n\r\n<pre>\r\n例子：\r\n普通函数\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\nfoo函数只是一个普通函数，但是当用new来创建对象的时候，foo就是构造函数了。\r\n\r\n <strong>prototype</strong>\r\n\r\n该函数有一个prototype属性，指向了一个对象，该对象是调用该构造函数创建的<strong>实例</strong>的原型\r\n\r\n例如这里，foo.prototype 是 test的原型\r\n\r\n什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，\r\n这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\r\n\r\n<strong>__proto__</strong>\r\n\r\n每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。\r\n所以在上面的例子中，obj的__proto__等于foo.prototype\r\nconsole.log(test.__proto__===foo.prototype) //true\r\n\r\n<strong>constructor</strong>\r\n\r\n每个原型都有一个 constructor 属性指向关联的构造函数。\r\nconsole.log(foo === foo.prototype.constructor); // true\r\n\r\n所以综上例子：\r\n\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\nconsole.log(test.__proto__ == foo.prototype) // true\r\nconsole.log(foo.prototype.constructor == foo) // true\r\n\r\n那么就会有一个疑问了，对象的原型是构造它的函数的prototype指向的对象，那么构造函数的prototype指向的对象是什么？\r\nconsole.log(foo.prototype.__proto___===Object.prototype) //true\r\n没错，通过比较我们知道，foo的prototype属性指向的对象的原型是 Object构造函数的prototype属性指向的对象 \r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\n还是这张图，很明显了~然后Object.prototype.contructor === Object \r\n\r\n都是类似与foo的形式，一层继承一层，这就是原型链，那么最终Obejct.prototype.__proto__是什么呢 是null，只有null没有任何属性了。\r\n\r\n对于这个例子\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\nvar obj=new foo(2,3);\r\n我们可以通过在test对象的原型上设置属性，从而变相地实现提供公有属性跟方法，从而来优化代码。\r\n增加一下代码：\r\nfoo.prototype.setName=function(name){this.name=name};\r\ntest.setName(\'jgchen\');\r\nconsole.log(test.name) //jgchen\r\nobj.setName(\'jgchenuu\');\r\nconsole.log(obj.name) //jgchenuu\r\n\r\n\r\n然后还可以设置公有属性，\r\nfoo.prototype.type=\'guang\';\r\nconsole.log(obj.type);//\'guang\'\r\nconsole.log(test.type);//\'guang\'\r\n\r\n当然这么设计类似于继承的方式是有缺陷的，关于原型链的继承方面，请移步另外一篇文章 <a href=\"http://jgchen.xin/index.php/2018/05/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD-es5%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/\" rel=\"noopener\" target=\"_blank\">前端面试中-es5原型链实现类与继承的几种方法</a>\r\n\r\n\r\n</pre>\r\n\r\n<pre>\r\n例子：\r\n普通函数\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\nfoo函数只是一个普通函数，但是当用new来创建对象的时候，foo就是构造函数了。\r\n\r\n <strong>prototype</strong>\r\n\r\n该函数有一个prototype属性，指向了一个对象，该对象是调用该构造函数创建的<strong>实例</strong>的原型\r\n\r\n例如这里，foo.prototype 是 test的原型\r\n\r\n什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，\r\n这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\r\n\r\n<strong>__proto__</strong>\r\n\r\n每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。\r\n所以在上面的例子中，obj的__proto__等于foo.prototype\r\nconsole.log(test.__proto__===foo.prototype) //true\r\n\r\n<strong>constructor</strong>\r\n\r\n每个原型都有一个 constructor 属性指向关联的构造函数。\r\nconsole.log(foo === foo.prototype.constructor); // true\r\n\r\n所以综上例子：\r\n\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\nconsole.log(test.__proto__ == foo.prototype) // true\r\nconsole.log(foo.prototype.constructor == foo) // true\r\n\r\n那么就会有一个疑问了，对象的原型是构造它的函数的prototype指向的对象，那么构造函数的prototype指向的对象是什么？\r\nconsole.log(foo.prototype.__proto___===Object.prototype) //true\r\n没错，通过比较我们知道，foo的prototype属性指向的对象的原型是 Object构造函数的prototype属性指向的对象 \r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\n还是这张图，很明显了~然后Object.prototype.contructor === Object \r\n\r\n都是类似与foo的形式，一层继承一层，这就是原型链，那么最终Obejct.prototype.__proto__是什么呢 是null，只有null没有任何属性了。\r\n\r\n对于这个例子\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\nvar obj=new foo(2,3);\r\n我们可以通过在test对象的原型上设置属性，从而变相地实现提供公有属性跟方法，从而来优化代码。\r\n增加一下代码：\r\nfoo.prototype.setName=function(name){this.name=name};\r\ntest.setName(\'jgchen\');\r\nconsole.log(test.name) //jgchen\r\nobj.setName(\'jgchenuu\');\r\nconsole.log(obj.name) //jgchenuu\r\n\r\n\r\n然后还可以设置公有属性，\r\nfoo.prototype.type=\'guang\';\r\nconsole.log(obj.type);//\'guang\'\r\nconsole.log(test.type);//\'guang\'\r\n\r\n当然这么设计类似于继承的方式是有缺陷的，关于原型链的继承方面，请移步另外一篇文章 <a href=\"http://jgchen.xin/index.php/2018/05/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD-es5%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/\" rel=\"noopener\" target=\"_blank\">前端面试中-es5原型链实现类与继承的几种方法</a>\r\n\r\n\r\n</pre>\r\n\r\n<pre>\r\n例子：\r\n普通函数\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\nfoo函数只是一个普通函数，但是当用new来创建对象的时候，foo就是构造函数了。\r\n\r\n <strong>prototype</strong>\r\n\r\n该函数有一个prototype属性，指向了一个对象，该对象是调用该构造函数创建的<strong>实例</strong>的原型\r\n\r\n例如这里，foo.prototype 是 test的原型\r\n\r\n什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，\r\n这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\r\n\r\n<strong>__proto__</strong>\r\n\r\n每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。\r\n所以在上面的例子中，obj的__proto__等于foo.prototype\r\nconsole.log(test.__proto__===foo.prototype) //true\r\n\r\n<strong>constructor</strong>\r\n\r\n每个原型都有一个 constructor 属性指向关联的构造函数。\r\nconsole.log(foo === foo.prototype.constructor); // true\r\n\r\n所以综上例子：\r\n\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\nconsole.log(test.__proto__ == foo.prototype) // true\r\nconsole.log(foo.prototype.constructor == foo) // true\r\n\r\n那么就会有一个疑问了，对象的原型是构造它的函数的prototype指向的对象，那么构造函数的prototype指向的对象是什么？\r\nconsole.log(foo.prototype.__proto___===Object.prototype) //true\r\n没错，通过比较我们知道，foo的prototype属性指向的对象的原型是 Object构造函数的prototype属性指向的对象 \r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\n还是这张图，很明显了~然后Object.prototype.contructor === Object \r\n\r\n都是类似与foo的形式，一层继承一层，这就是原型链，那么最终Obejct.prototype.__proto__是什么呢 是null，只有null没有任何属性了。\r\n\r\n对于这个例子\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\nvar obj=new foo(2,3);\r\n我们可以通过在test对象的原型上设置属性，从而变相地实现提供公有属性跟方法，从而来优化代码。\r\n增加一下代码：\r\nfoo.prototype.setName=function(name){this.name=name};\r\ntest.setName(\'jgchen\');\r\nconsole.log(test.name) //jgchen\r\nobj.setName(\'jgchenuu\');\r\nconsole.log(obj.name) //jgchenuu\r\n\r\n\r\n然后还可以设置公有属性，\r\nfoo.prototype.type=\'guang\';\r\nconsole.log(obj.type);//\'guang\'\r\nconsole.log(test.type);//\'guang\'\r\n\r\n当然这么设计类似于继承的方式是有缺陷的，关于原型链的继承方面，请移步另外一篇文章 <a href=\"http://jgchen.xin/index.php/2018/05/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD-es5%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/\" rel=\"noopener\" target=\"_blank\">前端面试中-es5原型链实现类与继承的几种方法</a>\r\n\r\n\r\n</pre>\r\n\r\n<pre>\r\n例子：\r\n普通函数\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\nfoo函数只是一个普通函数，但是当用new来创建对象的时候，foo就是构造函数了。\r\n\r\n <strong>prototype</strong>\r\n\r\n该函数有一个prototype属性，指向了一个对象，该对象是调用该构造函数创建的<strong>实例</strong>的原型\r\n\r\n例如这里，foo.prototype 是 test的原型\r\n\r\n什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，\r\n这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\r\n\r\n<strong>__proto__</strong>\r\n\r\n每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。\r\n所以在上面的例子中，obj的__proto__等于foo.prototype\r\nconsole.log(test.__proto__===foo.prototype) //true\r\n\r\n<strong>constructor</strong>\r\n\r\n每个原型都有一个 constructor 属性指向关联的构造函数。\r\nconsole.log(foo === foo.prototype.constructor); // true\r\n\r\n所以综上例子：\r\n\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\n\r\nconsole.log(test.__proto__ == foo.prototype) // true\r\nconsole.log(foo.prototype.constructor == foo) // true\r\n\r\n那么就会有一个疑问了，对象的原型是构造它的函数的prototype指向的对象，那么构造函数的prototype指向的对象是什么？\r\nconsole.log(foo.prototype.__proto___===Object.prototype) //true\r\n没错，通过比较我们知道，foo的prototype属性指向的对象的原型是 Object构造函数的prototype属性指向的对象 \r\n\r\n<img class=\"alignnone wp-image-634\" src=\"http://jgchen.xin/wp-content/uploads/2018/04/微信图片_20180605153557-300x163.png\" alt=\"\" width=\"680\" height=\"368\" />\r\n\r\n还是这张图，很明显了~然后Object.prototype.contructor === Object \r\n\r\n都是类似与foo的形式，一层继承一层，这就是原型链，那么最终Obejct.prototype.__proto__是什么呢 是null，只有null没有任何属性了。\r\n\r\n对于这个例子\r\nfunction foo(x,y){\r\n  this.x=x;\r\n  this.y=y;\r\n}\r\nvar test=new foo(1,2);\r\nvar obj=new foo(2,3);\r\n我们可以通过在test对象的原型上设置属性，从而变相地实现提供公有属性跟方法，从而来优化代码。\r\n增加一下代码：\r\nfoo.prototype.setName=function(name){this.name=name};\r\ntest.setName(\'jgchen\');\r\nconsole.log(test.name) //jgchen\r\nobj.setName(\'jgchenuu\');\r\nconsole.log(obj.name) //jgchenuu\r\n\r\n\r\n然后还可以设置公有属性，\r\nfoo.prototype.type=\'guang\';\r\nconsole.log(obj.type);//\'guang\'\r\nconsole.log(test.type);//\'guang\'\r\n\r\n当然这么设计类似于继承的方式是有缺陷的，关于原型链的继承方面，请移步另外一篇文章 <a href=\"http://jgchen.xin/index.php/2018/05/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD-es5%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/\" rel=\"noopener\" target=\"_blank\">前端面试中-es5原型链实现类与继承的几种方法</a>\r\n\r\n\r\n</pre>\r\n\r\n', '17', '2018-10-03 14:23:04', '2018-10-03 14:23:04');
INSERT INTO `content` VALUES ('15', '<p>阿萨德爱<span style=\"font-weight: bold;\">上阿萨德阿萨德阿萨德阿萨德阿萨德阿萨德阿萨德爱上的撒打算多</span></p><p><span style=\"font-weight: bold;\">啊实打实大阿萨德啊 阿萨德</span></p>', '18', '2018-10-03 14:32:08', '2018-10-03 14:32:08');
INSERT INTO `content` VALUES ('16', '<p>阿萨德爱迪生啊爱上</p>', '19', '2018-10-03 14:32:34', '2018-10-05 09:00:47');
INSERT INTO `content` VALUES ('17', '<p>阿萨德爱迪生啊爱上<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/50/pcmoren_huaixiao_org.png\" alt=\"[坏笑]\" data-w-e=\"1\"></p>', '20', '2018-10-03 14:33:03', '2018-10-07 07:50:13');
INSERT INTO `content` VALUES ('18', '<p>阿萨德爱迪生啊爱上</p>', '21', '2018-10-03 14:34:07', '2018-10-05 09:00:35');
INSERT INTO `content` VALUES ('19', '<p>ad啊啊啊</p>', '22', '2018-10-03 14:35:09', '2018-10-03 14:35:09');
INSERT INTO `content` VALUES ('20', '<h1><span style=\"background-color: rgb(249, 150, 59);\">爱上大的啊ad阿萨德阿萨德阿萨德阿萨德 爱上大的啊ad阿萨德阿萨德阿萨德阿萨德爱上大的啊ad阿萨德阿萨德阿萨德阿萨德爱上大的啊ad阿萨德阿萨德阿萨德阿萨德爱上大的啊ad阿萨德阿萨德阿爱上大的啊ad阿萨德阿萨德阿萨德阿萨德爱上大的啊ad阿萨德阿萨<span style=\"font-weight: bold;\">德阿萨德阿萨德爱上大的啊ad阿萨德阿</span></span><span style=\"font-weight: bold;\">爱上大的啊ad阿萨德阿萨德阿萨德阿萨德爱上大的啊ad阿萨德阿萨德阿萨德阿萨德爱上大的啊ad阿萨德阿萨德阿萨德阿萨德爱上大的啊ad阿萨德阿萨德阿萨德阿萨德爱上大的啊ad阿萨德阿萨德阿萨德阿萨德爱上大的啊ad阿萨德阿萨德阿萨德</span>阿萨<span style=\"background-color: rgb(249, 150, 59);\">德萨德阿萨德阿萨德爱上大的啊ad阿萨德</span>阿萨德阿萨德阿萨德萨德阿萨德&nbsp;</h1>', '23', '2018-10-03 14:39:33', '2018-10-03 14:39:33');
INSERT INTO `content` VALUES ('21', '<p>啊实打实大阿萨德阿萨德阿萨德阿萨德大声道萨达撒所多撒大所大所大所</p>', '24', '2018-10-04 17:06:29', '2018-10-04 21:48:49');
INSERT INTO `content` VALUES ('22', '<p>在使用sequelize 中，在模型关联上，遇到了挺多坑，官方文档也看得是一知半解。<br><br>举例说明<br></p><pre><code>model.user{<br>id:INTERGER,<br>institution_id:INTERGER<br>}<br><br>model.institutions{<br>id:INTERGER,<br>name:STRING<br>}</code></pre><p><br></p><p>通过例子来捋清楚逻辑<br><br>假如我现在有一个需求查询用户以及所属的组织；<br>那么在关联关系上 我要先查出来用户，然后再根据用户的institution_id来查用户的组织；<br>也就是左链接查询<br></p><pre><code>LEFT OUTER JOIN `institutions` AS `institution` ON `user`.`institution_id` = `institution`.`id`;</code></pre><p><br></p><p>那么需要编译后的sql代码是这样的，我需要将其关联起来，要怎么去关联呢。<br></p><pre><code>model.user.associate= function (models) {<br>models.user.belongsTo(models.institutions, {<br>foreignKey: \'institution_id\',<br>targetKey: \'id\',<br>constraints: false,<br>})<br>}</code></pre><p><br></p><p>源模型为user，目标模型为institutions，所以以user为主要关系查出来的就是用user的foreignKey===institutions的targetKey;查出来的数据，就是以user为主，institutions为辅的数据<br><br><br>假如我现在有一个需求查询用户以及所属的组织；<br>OUTER JOIN `user` AS `user` ON `institutions`.`id` = `user`.`institution_id`;<br>那么需要编译后的sql代码是这样的，我需要将其关联起来，要怎么去关联呢。<br></p><pre><code>model.user.associate= function (models) {<br>models.institutions.institutions(models.user, {<br>foreignKey: \'institution_id\',<br>sourceKey: \'id\',<br>constraints: false,<br>})<br>}</code></pre><p><br></p><p>源模型为institutions，目标模型为user，所以以institutions为主要关系查出来的就是用institutions的sourceKey===institutions的foreignKey；查出来的数据，就是以institutions为主，user为辅的数据<br></p>', '25', '2018-10-10 15:20:58', '2018-10-10 15:20:58');
INSERT INTO `content` VALUES ('23', '<p>测试一下哎</p>', '26', '2018-10-13 16:45:37', '2018-10-13 16:45:37');
INSERT INTO `content` VALUES ('24', '<p>按时打算打算大所多</p>', '27', '2018-10-19 16:24:40', '2018-10-19 16:26:59');
INSERT INTO `content` VALUES ('25', '<p>jgchen宿舍爱上打算大所多所大多</p>', '28', '2018-10-19 16:27:35', '2018-10-19 16:50:35');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `articleId` int(11) NOT NULL,
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=60 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES ('3', '生活', '2', '2018-09-30 09:47:00', '2018-09-30 09:47:03');
INSERT INTO `tag` VALUES ('4', '科技', '2', '2018-09-30 09:48:28', '2018-09-30 09:48:30');
INSERT INTO `tag` VALUES ('5', '兴趣', '3', '2018-09-30 09:52:11', '2018-09-30 09:52:13');
INSERT INTO `tag` VALUES ('6', '爱好', '4', '2018-09-30 09:52:28', '2018-09-30 09:52:32');
INSERT INTO `tag` VALUES ('7', '我家银', '8', '2018-10-02 09:14:35', '2018-10-02 09:14:35');
INSERT INTO `tag` VALUES ('8', '傻银', '8', '2018-10-02 09:14:35', '2018-10-02 09:14:35');
INSERT INTO `tag` VALUES ('9', '银宝宝', '8', '2018-10-02 09:14:35', '2018-10-02 09:14:35');
INSERT INTO `tag` VALUES ('10', '我家银', '9', '2018-10-02 09:19:04', '2018-10-02 09:19:04');
INSERT INTO `tag` VALUES ('11', '傻银', '9', '2018-10-02 09:19:04', '2018-10-02 09:19:04');
INSERT INTO `tag` VALUES ('12', '银宝宝', '9', '2018-10-02 09:19:04', '2018-10-02 09:19:04');
INSERT INTO `tag` VALUES ('13', '我家银', '10', '2018-10-02 09:27:55', '2018-10-02 09:27:55');
INSERT INTO `tag` VALUES ('14', '傻银', '10', '2018-10-02 09:27:55', '2018-10-02 09:27:55');
INSERT INTO `tag` VALUES ('15', '银宝宝', '10', '2018-10-02 09:27:55', '2018-10-02 09:27:55');
INSERT INTO `tag` VALUES ('16', '我爱我家傻银', '10', '2018-10-02 09:27:55', '2018-10-02 09:27:55');
INSERT INTO `tag` VALUES ('17', '我家银', '11', '2018-10-02 09:29:55', '2018-10-02 09:29:55');
INSERT INTO `tag` VALUES ('18', '傻银', '11', '2018-10-02 09:29:55', '2018-10-02 09:29:55');
INSERT INTO `tag` VALUES ('19', '银宝宝', '11', '2018-10-02 09:29:55', '2018-10-02 09:29:55');
INSERT INTO `tag` VALUES ('20', '我家银', '12', '2018-10-03 14:08:10', '2018-10-03 14:08:10');
INSERT INTO `tag` VALUES ('21', '傻银', '12', '2018-10-03 14:08:10', '2018-10-03 14:08:10');
INSERT INTO `tag` VALUES ('22', '银宝宝', '12', '2018-10-03 14:08:10', '2018-10-03 14:08:10');
INSERT INTO `tag` VALUES ('23', '你是不是傻子', '12', '2018-10-03 14:08:10', '2018-10-03 14:08:10');
INSERT INTO `tag` VALUES ('24', 'javascript', '13', '2018-10-03 14:13:06', '2018-10-03 14:13:06');
INSERT INTO `tag` VALUES ('25', '我家银', '14', '2018-10-03 14:19:38', '2018-10-03 14:19:38');
INSERT INTO `tag` VALUES ('26', '傻银', '14', '2018-10-03 14:19:38', '2018-10-03 14:19:38');
INSERT INTO `tag` VALUES ('27', '银宝宝', '14', '2018-10-03 14:19:38', '2018-10-03 14:19:38');
INSERT INTO `tag` VALUES ('28', '我家银', '15', '2018-10-03 14:20:53', '2018-10-03 14:20:53');
INSERT INTO `tag` VALUES ('29', '傻银', '15', '2018-10-03 14:20:53', '2018-10-03 14:20:53');
INSERT INTO `tag` VALUES ('30', '银宝宝', '15', '2018-10-03 14:20:53', '2018-10-03 14:20:53');
INSERT INTO `tag` VALUES ('31', '我家银', '16', '2018-10-03 14:22:53', '2018-10-03 14:22:53');
INSERT INTO `tag` VALUES ('32', '傻银', '16', '2018-10-03 14:22:53', '2018-10-03 14:22:53');
INSERT INTO `tag` VALUES ('33', '银宝宝', '16', '2018-10-03 14:22:53', '2018-10-03 14:22:53');
INSERT INTO `tag` VALUES ('34', '我家银', '17', '2018-10-03 14:23:04', '2018-10-03 14:23:04');
INSERT INTO `tag` VALUES ('35', '傻银', '17', '2018-10-03 14:23:04', '2018-10-03 14:23:04');
INSERT INTO `tag` VALUES ('36', '银宝宝', '17', '2018-10-03 14:23:04', '2018-10-03 14:23:04');
INSERT INTO `tag` VALUES ('37', '生活', '18', '2018-10-03 14:32:08', '2018-10-03 14:32:08');
INSERT INTO `tag` VALUES ('38', '生活', '22', '2018-10-03 14:35:09', '2018-10-03 14:35:09');
INSERT INTO `tag` VALUES ('39', '测试', '23', '2018-10-03 14:39:33', '2018-10-03 14:39:33');
INSERT INTO `tag` VALUES ('41', '测试', '24', '2018-10-04 21:48:49', '2018-10-04 21:48:49');
INSERT INTO `tag` VALUES ('42', '我爱我家小君君', '24', '2018-10-04 21:48:49', '2018-10-04 21:48:49');
INSERT INTO `tag` VALUES ('43', '傻银', '21', '2018-10-05 09:00:35', '2018-10-05 09:00:35');
INSERT INTO `tag` VALUES ('44', '傻银', '19', '2018-10-05 09:00:47', '2018-10-05 09:00:47');
INSERT INTO `tag` VALUES ('47', '傻银', '20', '2018-10-07 07:50:13', '2018-10-07 07:50:13');
INSERT INTO `tag` VALUES ('52', '生活', '1', '2018-10-10 15:18:55', '2018-10-10 15:18:55');
INSERT INTO `tag` VALUES ('53', '学习', '1', '2018-10-10 15:18:55', '2018-10-10 15:18:55');
INSERT INTO `tag` VALUES ('54', 'sequelize', '25', '2018-10-10 15:20:58', '2018-10-10 15:20:58');
INSERT INTO `tag` VALUES ('55', '测试', '26', '2018-10-13 16:45:37', '2018-10-13 16:45:37');
INSERT INTO `tag` VALUES ('57', 'jgchen', '27', '2018-10-19 16:26:59', '2018-10-19 16:26:59');
INSERT INTO `tag` VALUES ('59', 'jghcen', '28', '2018-10-19 16:50:35', '2018-10-19 16:50:35');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userName` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `authority` int(11) unsigned zerofill NOT NULL DEFAULT '00000000000',
  `introduction` text NOT NULL,
  `avatar` varchar(255) NOT NULL DEFAULT 'http://test.jgchen.xin/static/images/1.jpg',
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `userName` (`userName`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', 'jgchen', '$2b$10$8.J/LS2/.gYPBVwuN.Ycr.PGj4sFQManI82oaM6CbvGl4lWNgr9wG', '00000000001', '<ul>\n 	<li style=\"text-align: left;\">姓名：陈建光</li>\n 	<li style=\"text-align: left;\">学历：本科</li>\n 	<li style=\"text-align: left;\">院校：深圳大学</li>\n 	<li>性别：男</li>\n 	<li>目前：大三</li>\n 	<li>专业：信息工程</li>\n 	<li>爱前端爱生活</li>\n 	<li>github：<a href=\"https://github.com/jgchenu\">个人github</a></li>\n 	<li>邮箱：jgchenun@gmail.com</li>\n 	<li>sf社区：<a href=\"https://segmentfault.com/u/chenjianguang\">sf社区用户</a></li><li>我爱我家小君君</li>\n</ul>', 'http://localhost:8000/upload/0.4647523532394835.jpg', '2018-09-30 01:52:08', '2018-10-14 13:23:34');
INSERT INTO `user` VALUES ('2', 'tnsihy', 'jgchen', '00000000000', '困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困', 'http://test.jgchen.xin/static/images/1.jpg', '2018-10-06 13:26:32', '2018-10-06 13:26:34');
INSERT INTO `user` VALUES ('3', 'ceshi', 'jgchen', '00000000000', 'ceshi', 'http://test.jgchen.xin/static/images/1.jpg', '2018-10-06 15:59:24', '2018-10-06 15:59:27');
INSERT INTO `user` VALUES ('4', 'jg', '$2b$10$8.J/LS2/.gYPBVwuN.Ycr.PGj4sFQManI82oaM6CbvGl4lWNgr9wG', '00000000000', '<p>这个人很懒，什么都没有留下</p>', 'http://localhost:8000/upload/0.4605478836351671.jpg', '2018-10-16 02:57:44', '2018-10-19 08:43:11');
